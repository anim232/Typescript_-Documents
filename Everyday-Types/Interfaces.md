
### **TypeScript-এ Interface (ইন্টারফেস) কি?**

TypeScript-এ **interface** একটি বিশেষ ধরনের টাইপ যা একটি অবজেক্টের গঠন বা স্ট্রাকচার নির্ধারণ করে। অর্থাৎ, এটি নির্ধারণ করে যে কোনো অবজেক্টের মধ্যে কোন কোন প্রপার্টি এবং সেই প্রপার্টিগুলোর টাইপ কি হবে।

#### **Interface Declaration এর উদাহরণ:**

```typescript
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

এখানে `Point` নামক একটি ইন্টারফেস তৈরি করা হয়েছে, যেখানে `x` এবং `y` নামক দুটি প্রপার্টি রয়েছে, যার টাইপ `number`। এরপর `printCoord` ফাংশনে আমরা `Point` টাইপের একটি অবজেক্ট পাঠাচ্ছি এবং সেই অবজেক্টের `x` এবং `y` প্রপার্টি ব্যবহার করছি।

**এই উদাহরণে কি হচ্ছে:**
- `Point` ইন্টারফেসটি `x` এবং `y` নামে দুটি প্রপার্টি সহ একটি অবজেক্টের কাঠামো (structure) নির্ধারণ করছে।
- `printCoord` ফাংশনে এই কাঠামো অনুযায়ী অবজেক্টটি গৃহীত হচ্ছে এবং তার প্রপার্টিগুলি প্রিন্ট করা হচ্ছে।

TypeScript মূলত স্ট্রাকচারের উপর ভিত্তি করে কাজ করে, তাই এতে যে কোন অবজেক্টের কাঠামো বা স্ট্রাকচার মিললেই সেই অবজেক্টটি বৈধ হবে। 

### **Type Aliases এবং Interfaces এর মধ্যে পার্থক্য:**

TypeScript-এ **Type Aliases** এবং **Interfaces** এর কাজ প্রায় একই, কিন্তু কিছু পার্থক্য আছে। নিচে এর কিছু মূল পার্থক্য দেখানো হল:

#### 1. **Extend/বর্ধিত করা:**
- **Interface**: ইন্টারফেসগুলিকে আপনি একে অন্যের সাথে **extend** করতে পারেন।
  
  উদাহরণ:
  ```typescript
  interface Animal {
    name: string;
  }

  interface Bear extends Animal {
    honey: boolean;
  }

  const bear = { name: "Bear", honey: true };
  console.log(bear.name);  // Bear
  console.log(bear.honey); // true
  ```

- **Type Alias**: টাইপ অ্যালিয়াসকে **intersection** ব্যবহার করে একে অপরের সাথে সংযুক্ত করা যেতে পারে।
  
  উদাহরণ:
  ```typescript
  type Animal = { name: string };
  type Bear = Animal & { honey: boolean };

  const bear = { name: "Bear", honey: true };
  console.log(bear.name);  // Bear
  console.log(bear.honey); // true
  ```

#### 2. **নতুন ফিল্ড যুক্ত করা (Declaration Merging):**
- **Interface**: ইন্টারফেসগুলিকে **পুনরায় ঘোষণা (re-open)** করতে পারেন এবং এতে নতুন ফিল্ড যোগ করতে পারেন।
  
  উদাহরণ:
  ```typescript
  interface Window {
    title: string;
  }

  interface Window {
    ts: TypeScriptAPI;
  }

  const src = 'const a = "Hello World"';
  window.ts.transpileModule(src, {});
  ```

- **Type Alias**: টাইপ অ্যালিয়াসের ক্ষেত্রে আপনি একটি টাইপ একবার তৈরি করার পর আর তা পরিবর্তন করতে পারেন না। একই নামের দুটি টাইপ ঘোষণা করলে ত্রুটি হবে।
  
  উদাহরণ:
  ```typescript
  type Window = { title: string };
  type Window = { ts: TypeScriptAPI };  // Error: Duplicate identifier 'Window'.
  ```

#### 3. **Error Messages এ Name Display:**
- **Interface**: ইন্টারফেসের নাম **error message**-এ সবসময় দেখা যায়।
- **Type Alias**: টাইপ অ্যালিয়াসের নাম সবসময় error message-এ দেখা যায় না, কখনও কখনও অ্যানোনিমাস টাইপ (anonymous type) হিসেবে প্রদর্শিত হয়।

#### 4. **Performance:**
- **Interface**: `extends` ব্যবহার করার সময়, ইন্টারফেস কম্পাইলার জন্য বেশি পারফর্ম্যান্ট হতে পারে।
- **Type Alias**: টাইপ অ্যালিয়াসের ক্ষেত্রে সাধারণত কম্পাইলার কিছুটা ধীরগতির হতে পারে, বিশেষ করে যখন বিভিন্ন টাইপের মধ্যে intersection ব্যবহার করা হয়।

#### **Type Alias এর উদাহরণ:**

```typescript
type Point = {
  x: number;
  y: number;
};

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

এখানে, `Point` একটি টাইপ অ্যালিয়াস (type alias) যা `{ x: number; y: number }` ধরনের অবজেক্টের জন্য ব্যবহৃত হয়েছে। এটি ইন্টারফেসের মতোই কাজ করে, তবে একটি বড় পার্থক্য হলো টাইপ অ্যালিয়াস পরবর্তীতে পরিবর্তন বা এক্সটেন্ড করা সম্ভব নয়।

### **যখন Interface এবং Type Alias ব্যবহার করবেন:**

- **Interface** ব্যবহার করুন যদি আপনার প্রয়োজন হয়:
  - পরবর্তী সময়ে নতুন প্রপার্টি যোগ করতে (declaration merging)।
  - একাধিক ইন্টারফেসের মধ্যে inheritance বা extension করতে।
  - যখন আপনি ডাটা স্ট্রাকচারের স্ট্যান্ডার্ড পারফরম্যান্স চান।

- **Type Alias** ব্যবহার করুন যখন:
  - আপনি union বা intersection টাইপ তৈরি করতে চান।
  - আপনি immutable (অপরিবর্তনীয়) টাইপ চাচ্ছেন যা একবার তৈরি হলে পরিবর্তন হবে না।
  - খুবই জটিল টাইপ সিস্টেম তৈরি করতে চান।


- ইন্টারফেস এবং টাইপ অ্যালিয়াস অনেক সময় একই কাজ করতে পারে, তবে কিছু বিশেষ পরিস্থিতিতে এগুলির মধ্যে পার্থক্য রয়েছে।
- সাধারণত আপনি **interface** ব্যবহার করবেন যদি আপনার প্রোজেক্টের মধ্যে একাধিক টাইপ বা স্ট্রাকচারের মধ্যে সম্পর্ক থাকতে পারে এবং যদি আপনি একে একে নতুন প্রপার্টি যোগ করতে চান।
- যদি আপনার টাইপের স্ট্যাটিক কাঠামো তৈরি করতে হয় এবং আপনি এর মধ্যে কোনো পরিবর্তন চান না, তবে **type alias** ব্যবহার করবেন।

এভাবে আপনি TypeScript-এর **Interface** এবং **Type Aliases** সম্পর্কে অনেক কিছু শিখতে পারেন এবং প্রকল্পে তাদের সুবিধামত ব্যবহার করতে পারবেন।

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
## AGAIN EXPLAIN 
পুরোপুরি বোঝার জন্য আমাদের **Interface** এবং **Inheritance** এর ধারণা পরিষ্কারভাবে বুঝতে হবে। আমি সহজভাবে এবং উদাহরণ সহ ব্যাখ্যা করছি:

### **Interface কি?**

**Interface** (ইন্টারফেস) TypeScript-এর একটি বিশেষ feature যা কোনো অবজেক্টের গঠন বা structure কে সংজ্ঞায়িত (define) করতে সাহায্য করে। আপনি যদি ইন্টারফেস ব্যবহার করেন, তাহলে একটি নির্দিষ্ট গঠন তৈরি করতে পারবেন এবং তা ব্যবহার করতে পারবেন। এটি মূলত গঠনগতভাবে নির্দিষ্ট করে দেয় কোন প্রপার্টি থাকবে এবং সেই প্রপার্টির টাইপ কি হবে।

এটা যেমন:
- **Animal** ইন্টারফেসে একটি `name` প্রপার্টি থাকবে, যা `string` টাইপের।
- **Bear** ইন্টারফেসে `Animal` ইন্টারফেস থেকে প্রপার্টি নিয়ে `honey` নামে নতুন একটি প্রপার্টি যুক্ত করা হচ্ছে।

এটি খুব সহজভাবে দেখানো হচ্ছে:

### **কোড ব্যাখ্যা:**

```typescript
// প্রথমে Animal নামক ইন্টারফেস তৈরি করা হচ্ছে
interface Animal {
  name: string; // এখানে name প্রপার্টি টাইপ string হবে
}

// Bear নামক আরেকটি ইন্টারফেস যা Animal ইন্টারফেসটি extend (বর্ধিত) করবে
interface Bear extends Animal {
  honey: boolean; // এখানে honey প্রপার্টি টাইপ boolean হবে
}

// এখানে আমরা একটি Bear ধরনের অবজেক্ট তৈরি করছি যা name এবং honey দুটি প্রপার্টি থাকবে
const bear = { name: "Bear", honey: true };

// bear.name এবং bear.honey কে কনসোল আউটপুট করছি
console.log(bear.name);  // Bear
console.log(bear.honey); // true
```

### **এখানে কী ঘটছে?**

1. **Animal Interface:**  
   - `Animal` ইন্টারফেসে শুধুমাত্র একটি প্রপার্টি `name` থাকবে এবং এর টাইপ হবে `string`। এর মানে হল যে, `name` প্রপার্টি অবশ্যই একটি string টাইপের হতে হবে।
   
2. **Bear Interface (extends):**  
   - `Bear` ইন্টারফেসটি `Animal` ইন্টারফেসকে **extend** (বর্ধিত) করছে। এর মানে হল, `Bear` ইন্টারফেসের মধ্যে `Animal` ইন্টারফেসের সব প্রপার্টি থাকবে (যেমন `name`), আর নতুনভাবে `honey` নামে একটি প্রপার্টি যোগ করা হচ্ছে, যার টাইপ `boolean`।

3. **Object Creation:**  
   - `const bear = { name: "Bear", honey: true };` এখানে, `bear` একটি অবজেক্ট তৈরি করা হয়েছে, যা `Bear` ইন্টারফেসের গঠন অনুযায়ী:
     - `name` প্রপার্টি একটি `string` (এক্ষেত্রে `"Bear"`)।
     - `honey` প্রপার্টি একটি `boolean` (এক্ষেত্রে `true`)।

4. **Accessing Properties:**  
   - আমরা `bear.name` এবং `bear.honey` কে কনসোলে প্রিন্ট করছি।
     - `bear.name` আউটপুট করবে `"Bear"`, কারণ `name` প্রপার্টি `string` টাইপের।
     - `bear.honey` আউটপুট করবে `true`, কারণ `honey` প্রপার্টি `boolean` টাইপের।

### **এই কোডের উদ্দেশ্য কী?**

এটি **Inheritance** বা **extending** এর একটি উদাহরণ যেখানে আপনি একটি ইন্টারফেসের প্রপার্টি আরেকটি ইন্টারফেসে পুনঃব্যবহার (reuse) করতে পারেন এবং নতুন প্রপার্টি যুক্ত করতে পারেন।

এখানে, `Bear` ইন্টারফেসটি `Animal` ইন্টারফেসের `name` প্রপার্টি গ্রহণ করেছে এবং এতে নতুন `honey` প্রপার্টি যোগ করা হয়েছে। এর ফলে `Bear` ইন্টারফেসটি `Animal` ইন্টারফেসের সব কিছু পেয়েছে এবং নতুন কিছু যোগ করতে সক্ষম হয়েছে।

### **ইন্টারফেসে extends কীভাবে কাজ করে?**

1. **`extends` ব্যবহার করার মাধ্যমে:**  
   - একটি ইন্টারফেস অন্য একটি ইন্টারফেসকে **extend** করলে, তখন সেটি প্রথম ইন্টারফেসের সব প্রপার্টি স্বয়ংক্রিয়ভাবে পেয়ে যায়।
   
2. **নতুন প্রপার্টি যোগ করা:**  
   - এরপর নতুন কোনো প্রপার্টি যোগ করলে, সেই নতুন প্রপার্টি ঐ ইন্টারফেসের অংশ হয়ে যায়।

এটি মূলত অবজেক্ট ওবজেক্টের গঠন বা কাঠামোকে **inheritance** এর মাধ্যমে আরও পরিষ্কারভাবে সংজ্ঞায়িত করার কাজ করে।

### **কেন `extends` ব্যবহার করবেন?**
- যখন আপনি একটি ইন্টারফেসের কিছু প্রপার্টি reuse করতে চান অন্য একটি ইন্টারফেসে, এবং সেই ইন্টারফেসে নতুন কিছু প্রপার্টি যোগ করতে চান, তখন **`extends`** ব্যবহার করে নতুন ইন্টারফেস তৈরি করতে পারবেন।
  
এভাবে **Interface** এবং **extends** এর সাহায্যে TypeScript-এ আপনি অবজেক্টের কাঠামো (structure) পুনঃব্যবহার করতে পারেন এবং আরও সম্পূর্ণ কাঠামো তৈরি করতে পারেন।


- **`interface`** আপনার অবজেক্টের কাঠামো নির্ধারণ করে।
- **`extends`** ব্যবহার করে আপনি একটি ইন্টারফেসের প্রপার্টি অন্য একটি ইন্টারফেসে গ্রহণ করতে পারেন এবং নতুন প্রপার্টি যোগ করতে পারেন।
  
এইভাবে আপনি আপনার কোডকে আরও পরিষ্কার এবং পুনঃব্যবহারযোগ্য (reusable) করতে পারেন।



----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
আপনার যদি `interface` সম্পর্কে স্পষ্ট ধারণা না থাকে এবং আপনি বুঝতে চান কিভাবে এটি কাজ করে, তবে আমি খুব সহজ ভাষায় ব্যাখ্যা করছি।

### **1. Interface কি?**

**Interface** একটি টেমপ্লেট বা পরিকল্পনা, যা কোনো অবজেক্টের কাঠামো (structure) নির্ধারণ করে। এর মাধ্যমে আপনি **এমন একটি কাঠামো** তৈরি করতে পারেন, যা আপনার কোডে বিভিন্ন জায়গায় একইভাবে ব্যবহার করা যাবে।

এটা কল্পনা করুন, আপনি একটা **বাড়ির নকশা** তৈরি করছেন। বাড়ির নকশায় আপনি ঠিক করে দেন যে, বাড়িতে কতগুলো কক্ষ থাকবে, কতগুলো জানালা থাকবে, প্রতিটি কক্ষের আয়তন কী হবে। তবে বাড়ি যখন তৈরি হবে, তখন আপনি এক এক ধরনের কক্ষ বা জানালা ব্যবহার করতে পারেন, তবে তারা সেই নকশা অনুযায়ী থাকতে হবে। ঠিক তেমনি, **interface** দিয়ে আমরা অবজেক্টের কাঠামো বা গঠন ঠিক করে দিই।

### **2. Interface কিভাবে কাজ করে?**

ধরা যাক, আপনি একটি অবজেক্ট তৈরি করতে চান যার মধ্যে `name` এবং `age` প্রপার্টি থাকবে।

#### **Interface ব্যবহার না করে:**

```typescript
const person = { 
  name: "Alice", 
  age: 25 
};
```

এখানে, `person` অবজেক্টের মধ্যে `name` এবং `age` রয়েছে, কিন্তু এর কাঠামো বা গঠন আমরা কোথাও উল্লেখ করিনি।

#### **Interface ব্যবহার করে:**

এখন, **interface** ব্যবহার করলে আপনি একটি কাঠামো তৈরি করতে পারবেন, যেখানে `name` এবং `age` কি ধরনের তথ্য ধারণ করবে তা পরিষ্কারভাবে উল্লেখ করা যাবে।

```typescript
interface Person {
  name: string;
  age: number;
}

// এরপর, আপনি Person ইন্টারফেস ব্যবহার করে অবজেক্ট তৈরি করতে পারেন
const person: Person = { 
  name: "Alice", 
  age: 25 
};
```

এখানে, `Person` ইন্টারফেসটি বলছে যে, **যেকোনো `Person` টাইপের অবজেক্টের মধ্যে `name` থাকবে যেটি `string` টাইপের এবং `age` থাকবে যেটি `number` টাইপের**। এর মাধ্যমে আপনি অবজেক্টের কাঠামো ঠিক করে দিয়েছেন।

### **3. Interface কেন ব্যবহার করবেন?**

- **কাঠামো নির্ধারণ করা:** আপনি যখন জানেন যে আপনার অবজেক্টে কোন কোন প্রপার্টি থাকবে এবং তাদের কী ধরনের তথ্য থাকবে, তখন আপনি `interface` ব্যবহার করে সেই কাঠামো নির্ধারণ করতে পারেন।
  
- **কোডের পুনঃব্যবহার:** একবার একটি `interface` তৈরি করলে, আপনি সেই `interface` যেকোনো জায়গায় পুনরায় ব্যবহার করতে পারবেন, এতে কোড আরও পরিষ্কার ও সুশৃঙ্খল হবে।

- **টাইপ চেকিং:** TypeScript `interface` ব্যবহার করে আপনার কোডের টাইপ চেকিং (type checking) সহজতর করে দেয়, এবং যদি আপনি ভুলভাবে কোনো টাইপের মান দিতে যান, TypeScript তাতে সতর্ক করবে।

### **4. Interface-এর একটি উদাহরণ:**

ধরা যাক, আপনি একটি **Employee** ইন্টারফেস তৈরি করতে চান, যেখানে `name`, `id` এবং `salary` থাকবে।

```typescript
interface Employee {
  name: string;
  id: number;
  salary: number;
}

const employee1: Employee = {
  name: "John Doe",
  id: 101,
  salary: 50000
};

console.log(employee1.name);  // John Doe
console.log(employee1.id);    // 101
console.log(employee1.salary); // 50000
```

এখানে:
- **Employee** ইন্টারফেসটি বলে যে `Employee` অবজেক্টের মধ্যে `name` হবে `string` টাইপের, `id` হবে `number` টাইপের, এবং `salary` হবে `number` টাইপের।
- এর পর, আমরা `employee1` নামক অবজেক্ট তৈরি করেছি, যা `Employee` ইন্টারফেস অনুসরণ করছে।

### **5. Interface এর অন্যান্য সুবিধা:**

- **Extending Interfaces:** আপনি যদি একটি ইন্টারফেস থেকে অন্য একটি ইন্টারফেস তৈরি করতে চান, তবে `extends` ব্যবহার করতে পারেন।

```typescript
interface Manager extends Employee {
  department: string;
}

const manager: Manager = {
  name: "Sarah",
  id: 102,
  salary: 70000,
  department: "HR"
};
```

এখানে, `Manager` ইন্টারফেসটি `Employee` ইন্টারফেস থেকে সব প্রপার্টি পেয়েছে এবং তার সাথে একটি নতুন `department` প্রপার্টি যোগ করা হয়েছে।

### **6. Interface কোথায় ব্যবহার করবেন?**

- যখন আপনি কোনও ধরনের ডাটা বা অবজেক্টের গঠন পরিষ্কারভাবে ঠিক করতে চান, সেখানে আপনি `interface` ব্যবহার করবেন।
- যখন আপনি চাইবেন যে, সব অবজেক্টের মধ্যে নির্দিষ্ট প্রপার্টি থাকবে, তখন `interface` অত্যন্ত কার্যকর।

### **7. Interface vs Type Aliases:**

ইন্টারফেস এবং টাইপ এলিয়াস (type alias) প্রায় একই কাজ করে, তবে কিছু পার্থক্য রয়েছে। সাধারণত আপনি যখন ইন্টারফেসের কাঠামো তৈরি করবেন, তখন **`interface`** এবং **`extends`** এর সাহায্যে একে অপরের মধ্যে সম্পর্ক স্থাপন করতে পারবেন। অন্যদিকে, **`type alias`** সাধারণত আরো জটিল টাইপের জন্য ব্যবহৃত হয়।


- **Interface** হচ্ছে TypeScript-এর একটি শক্তিশালী উপাদান যা অবজেক্টের কাঠামো নির্ধারণ করে দেয়।
- এটি টাইপ সেফটি নিশ্চিত করতে সাহায্য করে এবং আপনার কোডকে আরও পরিষ্কার এবং অর্গানাইজড (organized) রাখে।
- আপনি যখন অবজেক্টের কাঠামো নির্দিষ্ট করতে চান, তখন `interface` ব্যবহার করা উপকারী।

আশা করি এখন আপনি `interface` বুঝতে পারছেন এবং কোথায় এটি ব্যবহার করবেন তা জানতেও পারবেন।





----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
## more explain 

### **তবে প্রথমে কিছু ব্যাখ্যা করা যাক:**

**Interfaces** এবং **Declaration Merging**:
- **Interface**: এর মাধ্যমে আমরা কোনও অবজেক্টের কাঠামো বা গঠন (structure) নির্ধারণ করি।
- **Declaration Merging**: এটি এমন একটি বৈশিষ্ট্য যেখানে আপনি একই নামের ইন্টারফেসকে একাধিক বার ঘোষণা (declare) করতে পারেন এবং TypeScript সেগুলিকে একসাথে মিলিয়ে (merge) দেয়।

### **কোডটি কীভাবে কাজ করে:**

```typescript
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}

const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

এটি TypeScript-এ **declaration merging** এর একটি উদাহরণ।

#### 1. প্রথম **interface Window**:
```typescript
interface Window {
  title: string;
}
```
এখানে, আপনি একটি **Window** নামক ইন্টারফেস ঘোষণা করছেন, যা একটি **`title`** প্রপার্টি ধারণ করবে এবং সেই প্রপার্টির টাইপ হবে **`string`**।

#### 2. দ্বিতীয় **interface Window**:
```typescript
interface Window {
  ts: TypeScriptAPI;
}
```
এখানে, আপনি আবার **Window** নামে একটি নতুন ইন্টারফেস ঘোষণা করেছেন, কিন্তু এবার আপনি **`ts`** নামক একটি নতুন প্রপার্টি যোগ করেছেন এবং এর টাইপ হিসেবে **`TypeScriptAPI`** ব্যবহার করছেন।

#### 3. Declaration Merging:
এখন, TypeScript **declaration merging** এর মাধ্যমে এই দুটি ইন্টারফেসকে একত্রিত (merge) করবে। এর মানে হলো:
- প্রথম ইন্টারফেসে `title` থাকবে (যার টাইপ `string`)।
- দ্বিতীয় ইন্টারফেসে `ts` থাকবে (যার টাইপ `TypeScriptAPI`)।
- এবং TypeScript এ দুটি ইন্টারফেসের মিশ্রণ তৈরি করবে। অর্থাৎ, **`Window`** ইন্টারফেসটি এখন দেখতে হবে এমন:
  
  ```typescript
  interface Window {
    title: string;
    ts: TypeScriptAPI;
  }
  ```

#### 4. কোডের কাজ:
```typescript
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```
এখানে, আপনি **`window.ts`** ব্যবহার করছেন। `window` এখন **`title`** এবং **`ts`** এই দুটি প্রপার্টি ধারণ করে। `ts` হল **`TypeScriptAPI`** টাইপের একটি অবজেক্ট, এবং এর `transpileModule` মেথডটি ব্যবহার করা হচ্ছে। অর্থাৎ, **`window.ts.transpileModule`** এর মাধ্যমে আপনি TypeScript কোডকে ট্রান্সপাইল (যেমন JavaScript এ রূপান্তর) করছেন।



- দুটি আলাদা **`Window`** ইন্টারফেস একসাথে মিশে গিয়ে একটি বড় ইন্টারফেস তৈরি করে, যার মধ্যে `title` এবং `ts` দুটি প্রপার্টি থাকবে।
- **`declaration merging`** এর মাধ্যমে এক ইন্টারফেসের সাথে অন্য ইন্টারফেসের প্রপার্টি যোগ হতে থাকে, এবং আপনি একটি সম্পূর্ণ ইন্টারফেস তৈরি করতে পারেন।
  
এটি TypeScript-এর **declaration merging** বৈশিষ্ট্য ব্যবহার করে। TypeScript একসাথে দুটি ইন্টারফেসের গঠনকে মেলায় এবং আমাদের **`window`** অবজেক্টে দুটি প্রপার্টি `title` (string টাইপ) এবং `ts` (TypeScriptAPI টাইপ) থাকে।

### **আশা করি এখন বিষয়টি পরিষ্কার হয়েছে!**



----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

এখন আমরা **ডিক্লারেশন মার্জিং (Declaration Merging)** নিয়ে বিস্তারিতভাবে  আলোচনা করি।

### 1. **ডিক্লারেশন মার্জিং কী?**

**ডিক্লারেশন মার্জিং** হল একটি TypeScript বৈশিষ্ট্য যা আপনাকে **একই নামের একাধিক ডিক্লারেশন** তৈরি করতে দেয় এবং TypeScript সেগুলোকে **একত্রিত (merge) করে** একটি একক ডিক্লারেশনে পরিণত করে। এটি বিশেষত তখন উপকারী যখন আপনি কোনো **ইন্টারফেস (interface)** বা **টাইপ (type)** এর মধ্যে নতুন প্রপার্টি বা ফিচার যোগ করতে চান।

### 2. **ডিক্লারেশন মার্জিং কীভাবে কাজ করে?**

যখন আপনি একই নামের জন্য **একাধিক ইন্টারফেস বা টাইপ ডিফাইন করেন**, TypeScript সেগুলিকে **অটোমেটিক্যালি একত্রিত (merge)** করে একটি একক টাইপ তৈরি করে। অর্থাৎ, একাধিক ডিক্লারেশনে যেসব প্রপার্টি বা ফিচার থাকে, সেগুলো সব একত্রিত হয়ে একে অপরের সাথে সংযুক্ত হয়ে যায়।

#### উদাহরণ:
ধরা যাক, আপনার কাছে একটি `Window` নামের ইন্টারফেস আছে যা দুটি আলাদা ডিক্লারেশন রয়েছে:

```typescript
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}
```

এখানে দুটি `Window` ইন্টারফেসের ডিক্লারেশন আছে। একটির মধ্যে `title` প্রপার্টি আছে এবং অন্যটির মধ্যে `ts` প্রপার্টি রয়েছে। TypeScript **এই দুইটি একসাথে মার্জ (merge) করবে** এবং একটি নতুন ইন্টারফেস তৈরি করবে যা উভয় প্রপার্টিকে ধারণ করবে।

অর্থাৎ, `Window` ইন্টারফেস এখন এমন হয়ে যাবে:

```typescript
interface Window {
  title: string;
  ts: TypeScriptAPI;
}
```

#### ব্যবহার:
এখন আপনি `Window` ইন্টারফেস ব্যবহার করতে পারবেন যা `title` এবং `ts` দুটো প্রপার্টি ধারণ করে। উদাহরণস্বরূপ:

```typescript
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

এখানে, `window` অবজেক্টের মধ্যে `title` এবং `ts` প্রপার্টি দুটোই থাকবে।

### 3. **ডিক্লারেশন মার্জিং কেন ব্যবহার করবেন?**

- **একই নামের ইন্টারফেস বা টাইপের বিভিন্ন অংশ যোগ করা**: যখন আপনি কোনো অবজেক্ট বা ডেটা স্ট্রাকচারের মধ্যে নতুন প্রপার্টি বা ফিচার যোগ করতে চান, তখন ডিক্লারেশন মার্জিং ব্যবহার করে সহজে এটি করতে পারেন।
  
- **থার্ড-পার্টি লাইব্রেরি বা কোডের সাথে কাজ করা**: ধরুন আপনি একটি লাইব্রেরি ব্যবহার করছেন এবং সেই লাইব্রেরি এর মধ্যে কিছু নতুন ফিচার যোগ করতে চান, তখন আপনি সেই লাইব্রেরির ইন্টারফেস বা টাইপের উপর মার্জিং ব্যবহার করতে পারেন।

- **কার্যকারিতা বাড়ানো**: ডিক্লারেশন মার্জিং ব্যবহার করে আপনি আপনার কোডের আরো নমনীয়তা বাড়াতে পারেন। আপনি আপনার ইন্টারফেস বা টাইপকে নতুন প্রপার্টি বা মেথডের সাথে সম্প্রসারিত করতে পারবেন।

### 4. **ডিক্লারেশন মার্জিংয়ের সুবিধা এবং সীমাবদ্ধতা**

#### সুবিধা:
- **বাড়তি প্রপার্টি যোগ করা সহজ**: একাধিক ইন্টারফেস বা টাইপ একত্রিত করে নতুন প্রপার্টি বা মেথড যোগ করা যায়।
- **থার্ড-পার্টি লাইব্রেরির সাথে সহজে ইন্টিগ্রেশন**: ডিক্লারেশন মার্জিংয়ের মাধ্যমে আপনি বাইরের লাইব্রেরির ইন্টারফেস পরিবর্তন বা সম্প্রসারিত করতে পারেন।

#### সীমাবদ্ধতা:
- **বিভিন্ন ডিক্লারেশনের মধ্যে কনফ্লিক্ট হতে পারে**: যদি একাধিক ডিক্লারেশন একই নামের জন্য একই প্রপার্টি বা মেথড সেট করে, তাহলে কনফ্লিক্ট হতে পারে।
- **প্রত্যাশিত আচরণ বুঝতে সমস্যা হতে পারে**: অনেক সময় একাধিক মার্জড ইন্টারফেস থেকে কি আসবে এবং কিভাবে কাজ করবে তা সঠিকভাবে বুঝতে সমস্যা হতে পারে।

### 5. **উদাহরণ**
এখন একটি বাস্তব উদাহরণ দেখা যাক:

```typescript
// প্রথম ডিক্লারেশন
interface Window {
  title: string;
}

// দ্বিতীয় ডিক্লারেশন
interface Window {
  ts: TypeScriptAPI;
}

// এখন আমরা `window` অবজেক্ট ব্যবহার করতে পারব
const myWindow: Window = {
  title: "My Window",
  ts: someTypeScriptAPI
};
```

এখানে, প্রথম `Window` ইন্টারফেসের `title` প্রপার্টি ছিল এবং দ্বিতীয় `Window` ইন্টারফেসে `ts` প্রপার্টি ছিল। TypeScript এই দুটি একত্রিত করে `Window` ইন্টারফেস তৈরি করেছে, যাতে উভয় প্রপার্টি থাকবে। তাই, `myWindow` অবজেক্টে `title` এবং `ts` উভয়ই থাকবে।

---

এভাবে TypeScript ডিক্লারেশন মার্জিংয়ের মাধ্যমে আপনি **একই নামের একাধিক ডিক্লারেশন** ব্যবহার করে **নতুন প্রপার্টি বা ফিচার যোগ** করতে পারেন।


----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
**Interface Declaration Merging** কিভাবে কাজ করে, তা বোঝানো হবে।

### নতুন উদাহরণ: ডিক্লেয়ারেশন মার্জিং

ধরা যাক, আমাদের একটি `Employee` ইন্টারফেস আছে, যা একজন কর্মীর তথ্য ধারণ করবে। তারপর, আমরা একটি নতুন ইন্টারফেস ঘোষণা করব এবং পুরানো ইন্টারফেসের সাথে মার্জ করব। এই উদাহরণে, আমরা মার্জিংয়ের মাধ্যমে নতুন প্রপার্টি যোগ করবো।

### কোড:

```typescript
// প্রথম ইন্টারফেস: Employee
interface Employee {
  name: string;
  age: number;
}

// দ্বিতীয় ইন্টারফেস: Employee এর সাথে নতুন প্রপার্টি যোগ করা হচ্ছে
interface Employee {
  department: string;
  salary: number;
}

// এখন, আমরা একটি অবজেক্ট তৈরি করি Employee টাইপের, যা দুটি ইন্টারফেসের সব প্রপার্টি ধারণ করবে
const emp: Employee = {
  name: "John Doe",
  age: 28,
  department: "Engineering",
  salary: 50000
};

console.log(emp.name);        // John Doe
console.log(emp.age);         // 28
console.log(emp.department);  // Engineering
console.log(emp.salary);      // 50000
```

### ব্যাখ্যা:

1. **প্রথম ইন্টারফেস (Employee):**  
   এখানে, প্রথম ইন্টারফেস `Employee` ঘোষণা করা হয়েছে যেখানে দুটি প্রপার্টি আছে:
   - `name: string` (কর্মীর নাম)
   - `age: number` (কর্মীর বয়স)

2. **দ্বিতীয় ইন্টারফেস (Employee):**  
   এর পরে, আমরা আবার একই নামের `Employee` ইন্টারফেস ঘোষণা করেছি, কিন্তু এবার দুটি নতুন প্রপার্টি যোগ করেছি:
   - `department: string` (কর্মীর বিভাগ)
   - `salary: number` (কর্মীর বেতন)

3. **ডিক্লেয়ারেশন মার্জিং:**  
   TypeScript এই দুটি `Employee` ইন্টারফেস একত্রিত করে একটি নতুন ইন্টারফেস তৈরি করবে, যার মধ্যে মোট চারটি প্রপার্টি থাকবে:
   - `name: string`
   - `age: number`
   - `department: string`
   - `salary: number`

4. **অবজেক্ট তৈরি:**  
   এখন, যখন আমরা `Employee` টাইপের একটি অবজেক্ট তৈরি করি, তখন এটি সব চারটি প্রপার্টি ধারণ করবে: `name`, `age`, `department`, এবং `salary`।

5. **কনসোল আউটপুট:**  
   আমরা কনসোল লগের মাধ্যমে অবজেক্টের সব প্রপার্টি দেখতে পাচ্ছি, যেমন:
   - `emp.name`  → `John Doe`
   - `emp.age`   → `28`
   - `emp.department` → `Engineering`
   - `emp.salary` → `50000`

### কেন Declaration Merging ব্যবহার করা হচ্ছে?

**Declaration Merging** TypeScript-এর একটি শক্তিশালী ফিচার যা একই নামের ইন্টারফেস একত্রিত করার সুযোগ দেয়। এর ফলে, আমরা একাধিক স্থানে একই নামের ইন্টারফেস ঘোষণা করতে পারি এবং TypeScript স্বয়ংক্রিয়ভাবে সব প্রপার্টি মার্জ করে।

এটি সাধারণত বড় কোডবেস বা লাইব্রেরি ব্যবহারের সময় কাজে আসে, যেখানে আপনি একটি ইন্টারফেসের নতুন প্রপার্টি বা ফিচার যুক্ত করতে পারেন, বিশেষ করে যখন অন্যদের কোডে কোনো পরিবর্তন না এনে নতুন ফিচার যোগ করতে হয়।

### উদাহরণ যেখানে Declaration Merging বিশেষভাবে ব্যবহার হয়:

ধরা যাক, আপনি একটি ব্রাউজার বা বড় অ্যাপ্লিকেশন তৈরি করছেন এবং তার পরবর্তী আপডেটের জন্য কিছু নতুন প্রপার্টি যোগ করতে চান, কিন্তু আগের কোডে কোনো পরিবর্তন করতে চান না। আপনি ঐ একই নামের ইন্টারফেস ব্যবহার করে নতুন প্রপার্টি যোগ করতে পারেন।


----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
**ডিক্লেয়ারেশন মার্জিং** ব্যবহার করা হচ্ছে

### নতুন উদাহরণ: Declaration Merging

এবার আমি **Declaration Merging** ব্যবহার করে একটি বাস্তব উদাহরণ দেব, যেখানে আমরা **একই নামের ইন্টারফেস** একাধিকবার ঘোষণা করব এবং TypeScript সেই দুটি ইন্টারফেস একত্রিত করে মার্জ করবে।

### কোড:

```typescript
// প্রথম ইন্টারফেস: Library (লাইব্রেরির প্রাথমিক তথ্য)
interface Library {
  name: string;
  location: string;
}

// দ্বিতীয় ইন্টারফেস: Library (লাইব্রেরির আরও তথ্য যোগ করা হচ্ছে)
interface Library {
  booksAvailable: number;
  hasOnlineCatalog: boolean;
}

// এখন, একটি অবজেক্ট তৈরি করি 'Library' টাইপের, যেটি দুটি ইন্টারফেসের সব প্রপার্টি ধারণ করবে
const myLibrary: Library = {
  name: "Central Library",
  location: "Downtown",
  booksAvailable: 5000,
  hasOnlineCatalog: true
};

// কনসোল লগে সব প্রপার্টি দেখা যাচ্ছে
console.log(myLibrary.name);             // Central Library
console.log(myLibrary.location);         // Downtown
console.log(myLibrary.booksAvailable);   // 5000
console.log(myLibrary.hasOnlineCatalog); // true
```

### ব্যাখ্যা:

1. **প্রথম ইন্টারফেস (Library):**  
   প্রথমে, আমরা `Library` নামের একটি ইন্টারফেস ঘোষণা করি যেখানে **`name`** এবং **`location`** নামে দুটি প্রপার্টি রয়েছে।  
   ```typescript
   interface Library {
     name: string;
     location: string;
   }
   ```

2. **দ্বিতীয় ইন্টারফেস (Library):**  
   তারপর, আমরা আবার **`Library`** নামের আরেকটি ইন্টারফেস ঘোষণা করি এবং এতে নতুন দুটি প্রপার্টি যোগ করি:
   - `booksAvailable: number` (লাইব্রেরিতে বইয়ের সংখ্যা)
   - `hasOnlineCatalog: boolean` (লাইব্রেরির কি অনলাইন ক্যাটালগ রয়েছে?)
   ```typescript
   interface Library {
     booksAvailable: number;
     hasOnlineCatalog: boolean;
   }
   ```

3. **ডিক্লেয়ারেশন মার্জিং:**  
   TypeScript এই দুটি ইন্টারফেস মার্জ করবে। অর্থাৎ, `Library` নামের ইন্টারফেসের মধ্যে সব প্রপার্টি একত্রিত হয়ে যাবে। এখন, এই ইন্টারফেসটি হবে:
   - `name: string`
   - `location: string`
   - `booksAvailable: number`
   - `hasOnlineCatalog: boolean`

   TypeScript স্বয়ংক্রিয়ভাবে এই সব প্রপার্টি একত্রিত করবে এবং `Library` টাইপের অবজেক্টে ব্যবহার করতে পারব।

4. **অবজেক্ট তৈরি:**  
   আমরা `myLibrary` নামে একটি অবজেক্ট তৈরি করি যা `Library` টাইপের এবং এতে সব প্রপার্টি থাকবে:
   - `name: "Central Library"`
   - `location: "Downtown"`
   - `booksAvailable: 5000`
   - `hasOnlineCatalog: true`

5. **কনসোল আউটপুট:**  
   অবজেক্টের সব প্রপার্টি কনসোল লগে আউটপুট হিসেবে দেখাচ্ছি:
   - `myLibrary.name` → `"Central Library"`
   - `myLibrary.location` → `"Downtown"`
   - `myLibrary.booksAvailable` → `5000`
   - `myLibrary.hasOnlineCatalog` → `true`

### কেন Declaration Merging ব্যবহার করা হচ্ছে?

**Declaration Merging** ব্যবহার করা হয়েছে যাতে:
- আপনি একটি ইন্টারফেসকে কয়েকটি অংশে ভাগ করতে পারেন এবং সেগুলো পরে একত্রিত হয়ে একটি সম্পূর্ণ ইন্টারফেসে পরিণত হবে।
- এটি বড় অ্যাপ্লিকেশনে খুব উপকারী, যেখানে একে অপরের সাথে কোডের বিভিন্ন অংশের জন্য একাধিক ইন্টারফেস যুক্ত করা হয়, কিন্তু পুরানো কোডে কোনো পরিবর্তন আনতে হয় না।
  
যেমন, যদি আপনি প্রথমে একটি সাধারণ `Library` ইন্টারফেস তৈরি করেন, পরে নতুন কোনো প্রপার্টি যোগ করতে চান, তবে আপনি আবার `Library` ইন্টারফেস ব্যবহার করতে পারেন, এবং TypeScript সেগুলো একত্রিত করবে।



- **Declaration Merging** খুবই শক্তিশালী এবং TypeScript আপনাকে একই নামের ইন্টারফেস একাধিকবার ব্যবহার করতে দেয়। এতে আপনার কোডকে আরও মডুলার এবং সুষম রাখা সম্ভব হয়।
- আপনি যখন একটি লাইব্রেরি বা বড় অ্যাপ্লিকেশন তৈরি করছেন এবং এতে বিভিন্ন অংশের তথ্য একত্রিত করতে চান, তখন Declaration Merging অত্যন্ত সাহায্যকারী হয়।

এটি **TypeScript**-এর একটি অসাধারণ বৈশিষ্ট্য যা কোডকে আরও শক্তিশালী এবং নমনীয় করে তোলে।




----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------


- একটি কাস্টম **Library** তৈরি করা যেখানে একাধিক ইন্টারফেস মার্জ (merging) করা হবে।
- একটি বেস ইন্টারফেস দিয়ে শুরু করা এবং তা থেকে **extends** করা।

### উদাহরণ:

ধরা যাক আমাদের একটি `Library` নামের ইন্টারফেস রয়েছে এবং আমরা সেটি **extend** করে আরও কিছু নতুন তথ্য যোগ করতে চাই। এরপর, আমরা **declaration merging** ব্যবহার করব।

### কোড:

```typescript
// প্রথম ইন্টারফেস: Library (লাইব্রেরির মূল তথ্য)
interface Library {
  name: string;
  location: string;
}

// দ্বিতীয় ইন্টারফেস: Library (লাইব্রেরির আরও কিছু প্রপার্টি যোগ করা)
interface Library {
  booksAvailable: number;
  hasOnlineCatalog: boolean;
}

// বেস ইন্টারফেস: LibraryUser (লাইব্রেরি ব্যবহারকারীর তথ্য)
interface LibraryUser {
  userId: number;
  userName: string;
}

// LibraryUser ইন্টারফেসকে আমরা Library এর সাথে merge করতে যাচ্ছি
interface LibraryUser extends Library {
  borrowedBooks: string[];
}

// অবশেষে, আমরা একটি অবজেক্ট তৈরি করব যা Library এবং LibraryUser দুটো ইন্টারফেসকেই একসাথে ধারণ করবে।
const myLibraryUser: LibraryUser = {
  name: "Central Library",
  location: "Downtown",
  booksAvailable: 5000,
  hasOnlineCatalog: true,
  userId: 101,
  userName: "Alice",
  borrowedBooks: ["Harry Potter", "JavaScript Guide"]
};

// কনসোল লগে অবজেক্টের সব প্রপার্টি প্রদর্শন
console.log(myLibraryUser.name);              // Central Library
console.log(myLibraryUser.location);          // Downtown
console.log(myLibraryUser.booksAvailable);    // 5000
console.log(myLibraryUser.hasOnlineCatalog);  // true
console.log(myLibraryUser.userId);            // 101
console.log(myLibraryUser.userName);          // Alice
console.log(myLibraryUser.borrowedBooks);     // [ 'Harry Potter', 'JavaScript Guide' ]
```

### ব্যাখ্যা:

1. **প্রথম ইন্টারফেস `Library`:**
   - এখানে আমরা `Library` নামে একটি ইন্টারফেস তৈরি করেছি যার মধ্যে ২টি প্রপার্টি রয়েছে:
     - `name: string` (লাইব্রেরির নাম)
     - `location: string` (লাইব্রেরির অবস্থান)

   ```typescript
   interface Library {
     name: string;
     location: string;
   }
   ```

2. **দ্বিতীয় ইন্টারফেস `Library`:**
   - এরপর আমরা আবার একই নামের `Library` ইন্টারফেস তৈরি করি, কিন্তু এবার আরও কিছু নতুন প্রপার্টি যোগ করি:
     - `booksAvailable: number` (লাইব্রেরিতে কতগুলো বই রয়েছে)
     - `hasOnlineCatalog: boolean` (লাইব্রেরিতে কি অনলাইন ক্যাটালগ রয়েছে?)

   ```typescript
   interface Library {
     booksAvailable: number;
     hasOnlineCatalog: boolean;
   }
   ```

   **Declaration Merging**: TypeScript স্বয়ংক্রিয়ভাবে এই দুটি ইন্টারফেস একত্রিত করবে, ফলে আমাদের `Library` ইন্টারফেসে **name**, **location**, **booksAvailable**, এবং **hasOnlineCatalog** এই চারটি প্রপার্টি থাকবে।

3. **নতুন ইন্টারফেস `LibraryUser`:**
   - এবার আমরা একটি নতুন ইন্টারফেস `LibraryUser` তৈরি করেছি, যা ব্যবহারকারী সম্পর্কিত তথ্য ধারণ করবে:
     - `userId: number` (ব্যবহারকারীর আইডি)
     - `userName: string` (ব্যবহারকারীর নাম)
     
   ```typescript
   interface LibraryUser {
     userId: number;
     userName: string;
   }
   ```

4. **`LibraryUser` ইন্টারফেসকে `Library` ইন্টারফেস থেকে এক্সটেন্ড করা:**
   - আমরা `LibraryUser` ইন্টারফেসটিকে **extends** keyword দিয়ে `Library` ইন্টারফেস থেকে এক্সটেন্ড করেছি, অর্থাৎ `LibraryUser` এখন `Library` ইন্টারফেসের সব প্রপার্টি এবং আরও কিছু নতুন প্রপার্টি ধারণ করবে।
   - এখানে নতুন প্রপার্টি হিসাবে যোগ করা হয়েছে:
     - `borrowedBooks: string[]` (ব্যবহারকারী যে বইগুলো ধার নিয়েছে, সেগুলোর তালিকা)

   ```typescript
   interface LibraryUser extends Library {
     borrowedBooks: string[];
   }
   ```

5. **অবশেষে, একটি অবজেক্ট তৈরি করা `LibraryUser` টাইপের:**
   - এখন, আমরা `myLibraryUser` নামের একটি অবজেক্ট তৈরি করেছি যা `LibraryUser` টাইপের। এর মধ্যে সবগুলো প্রপার্টি থাকবে:
     - `name`, `location`, `booksAvailable`, `hasOnlineCatalog`, `userId`, `userName`, এবং `borrowedBooks`।

6. **কনসোল আউটপুট:**
   - অবজেক্টের সব প্রপার্টি কনসোল লগে আউটপুট দেখানো হয়েছে:
     - লাইব্রেরির নাম, অবস্থান, বইয়ের সংখ্যা, অনলাইন ক্যাটালগের অবস্থা, ব্যবহারকারীর আইডি, নাম এবং ধার করা বইগুলোর তালিকা।

### **Why use `extends` and Merging here?**

- **`extends`**: এখানে `LibraryUser` ইন্টারফেসকে `Library` ইন্টারফেস থেকে এক্সটেন্ড করা হয়েছে, যার মাধ্যমে `LibraryUser` ইন্টারফেসটি `Library` এর সব প্রপার্টি পেয়ে যায়। এটি ব্যবহারকারীকে লাইব্রেরির সম্পূর্ণ তথ্য প্রদানের জন্য সহায়ক।
  
- **Declaration Merging**: এখানে আমরা একাধিকবার `Library` ইন্টারফেস ডিফাইন করেছি, এবং TypeScript স্বয়ংক্রিয়ভাবে তাদের মার্জ করেছে, ফলে লাইব্রেরি সম্পর্কে আরও বিস্তৃত তথ্য প্রদান করা সম্ভব হয়েছে।

এই পদ্ধতিটি বড় অ্যাপ্লিকেশন বা লাইব্রেরির কোডে খুব উপকারী, যেখানে আপনি বিভিন্ন অংশে আলাদা আলাদা তথ্য যোগ করতে পারেন, এবং শেষে এগুলো একত্রিত করে একটি পূর্ণাঙ্গ অবজেক্ট তৈরি করতে পারেন। 

এভাবে আপনি TypeScript-এর `extends` এবং **declaration merging** এর শক্তি ব্যবহার করে কোড আরও মডুলার এবং পঠনযোগ্য রাখতে পারেন।


----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
