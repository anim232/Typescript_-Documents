### The Primitives: `string`, `number`, and `boolean` in TypeScript

JavaScript এবং TypeScript-এর মধ্যে অনেক ধরনের ডেটা টাইপ থাকে, যার মধ্যে **string**, **number**, এবং **boolean** সবচেয়ে সাধারণ এবং গুরুত্বপূর্ণ। এগুলোর সাহায্যে আমরা সাধারণ ডেটা সংরক্ষণ এবং প্রক্রিয়া করতে পারি। এখানে আমরা এই তিনটি প্রিমিটিভ টাইপ সম্পর্কে বিস্তারিতভাবে জানবো।

---

### ১. **string (স্ট্রিং)**
**`string`** টাইপের মান হলো টেক্সটের মান। একে আপনি সাধারণত আলফানিউমেরিক (অক্ষর, সংখ্যা) বা বিশেষ চিহ্ন দিয়ে গঠিত যেকোনো টেক্সট হিসেবে ব্যবহার করতে পারেন।

- **ব্যবহার**: কোনো টেক্সট বা স্ট্রিং স্টোর করার জন্য।
- **উদাহরণ**: `"Hello, world!"`, `"TypeScript"`, `"I love coding!"`

**TypeScript Syntax**:
```typescript
let message: string = "Hello, world!";
```

এখানে `message` ভেরিয়েবলটির টাইপ হলো `string`, যার মান হলো `"Hello, world!"`। 

**JavaScript Comparison**:  
JavaScript-এ `typeof` অপারেটর ব্যবহার করে আপনি জানবেন যে একটি ভেরিয়েবলের মান যদি `string` হয়:
```javascript
let message = "Hello, world!";
console.log(typeof message);  // "string"
```

---

### ২. **number (নম্বর)**
**`number`** টাইপে আপনি কোনো সংখ্যা সংরক্ষণ করতে পারেন, যেটি ইনটিজার বা দশমিক সংখ্যা (float) যাই হোক না কেন। JavaScript-এ কোনো আলাদা টাইপ নেই ইনটিজার বা ফ্লোটের জন্য, সব কিছুই `number` টাইপেই রাখা হয়।

- **ব্যবহার**: সংখ্যাগুলি যেমন ৫, ৩.১৪, -১০, ৭৩ ইত্যাদি স্টোর করার জন্য।
- **উদাহরণ**: `42`, `3.14`, `-100`, `0`

**TypeScript Syntax**:
```typescript
let age: number = 25;
let pi: number = 3.14;
```

এখানে `age` ভেরিয়েবলটি `number` টাইপের এবং এর মান ২৫। একইভাবে `pi` হলো `number` টাইপের এবং এর মান ৩.১৪।

**JavaScript Comparison**:  
JavaScript-এ `typeof` অপারেটর ব্যবহার করে আপনি জানবেন যে একটি ভেরিয়েবলের মান যদি `number` হয়:
```javascript
let age = 25;
console.log(typeof age);  // "number"
```

---

### ৩. **boolean (বুলিয়ান)**
**`boolean`** টাইপে দুটি মান থাকতে পারে: `true` অথবা `false`। এটি সাধারণত লগিক্যাল অপারেশনে (যেমন শর্তাবলী চেক করা) ব্যবহৃত হয়।

- **ব্যবহার**: শর্ত যাচাই করার জন্য (যেমন, `if` বা `while` লুপে), সত্য বা মিথ্যা (true/false) মান সংরক্ষণ করার জন্য।
- **উদাহরণ**: `true`, `false`

**TypeScript Syntax**:
```typescript
let isCompleted: boolean = true;
let hasError: boolean = false;
```

এখানে `isCompleted` ভেরিয়েবলটির মান `true` এবং `hasError` ভেরিয়েবলটির মান `false`।

**JavaScript Comparison**:  
JavaScript-এ `typeof` অপারেটর ব্যবহার করে আপনি জানবেন যে একটি ভেরিয়েবলের মান যদি `boolean` হয়:
```javascript
let isCompleted = true;
console.log(typeof isCompleted);  // "boolean"
```

---

### **Important Notes (গুরুত্বপূর্ণ তথ্য)**

1. **Capitalized Types**:
   TypeScript-এ **`String`**, **`Number`**, এবং **`Boolean`** (প্রথম অক্ষর বড়) টাইপ নামগুলো বৈধ, কিন্তু এগুলো সাধারণত খুব কম ব্যবহার হয়। এগুলো কিছু বিশেষ বিল্ট-ইন টাইপের প্রতিনিধিত্ব করে, তবে সাধারণভাবে `string`, `number`, এবং `boolean` নামগুলোই ব্যবহার করা উচিত।

   উদাহরণ:
   ```typescript
   let str: String = "Hello"; // এ ধরনের ব্যবহার এড়ানো উচিত।
   let num: Number = 42;     // এ ধরনের ব্যবহার এড়ানো উচিত।
   let bool: Boolean = true; // এ ধরনের ব্যবহার এড়ানো উচিত।
   ```

2. **TypeScript vs JavaScript**:
   TypeScript এবং JavaScript-এ `string`, `number`, এবং `boolean` এর ব্যবহার একেবারে একরকম। তবে, TypeScript-এ আমরা টাইপ সেফটি (type safety) পেয়ে থাকি, যার মাধ্যমে ভুল টাইপ বা মান প্রয়োগে টাইপ চেকিংয়ের মাধ্যমে ত্রুটি পাওয়া যায়।

---

### **Summary **
- **`string`**: টেক্সট বা অক্ষরসমূহের জন্য ব্যবহৃত হয়।
- **`number`**: সংখ্যার জন্য ব্যবহৃত হয় (ইনটিজার বা দশমিক সংখ্যা)।
- **`boolean`**: `true` অথবা `false` মানের জন্য ব্যবহৃত হয়।

এই তিনটি প্রিমিটিভ টাইপ TypeScript-এ খুবই গুরুত্বপূর্ণ এবং আপনার কোডে এর ব্যবহার নিশ্চিত করতে টাইপ অ্যানোটেশন ব্যবহার করা খুবই সহায়ক। TypeScript এর শক্তিশালী টাইপ সিস্টেম আপনাকে ভুল টাইপের মান ব্যবহার থেকে রক্ষা করে, যাতে আপনার কোড আরও নির্ভরযোগ্য হয়।

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
### TypeScript-এ **Arrays** (অ্যারেগুলি)

TypeScript-এ **Arrays** (অ্যারেগুলি) হলো এক ধরনের ডেটা স্ট্রাকচার যেখানে একাধিক মান বা ভ্যালু সংরক্ষণ করা যায়। JavaScript-এ যেমন অ্যারে ব্যবহার করা হয়, TypeScript-এও একইভাবে অ্যারে ব্যবহার করা হয়, তবে TypeScript এর বিশেষত্ব হলো যে, আপনি অ্যারের ভিতরে কোন ধরনের ডেটা থাকবে তা টাইপ সিস্টেম দিয়ে নির্দিষ্ট করে দিতে পারবেন। 

আসুন, একে একে বিস্তারিতভাবে বুঝে নিন:

---

### ১. **Array টাইপ নির্ধারণ (Array Type Declaration)**

TypeScript-এ অ্যারের টাইপ নির্ধারণের জন্য কিছু বিশেষ সিনট্যাক্স (syntax) রয়েছে। সাধারণত, অ্যারে টাইপ নির্ধারণ করতে দুটি উপায় রয়েছে:

1. **`type[]`** সিনট্যাক্স
2. **`Array<type>`** সিনট্যাক্স

উদাহরণস্বরূপ, যদি আপনি চান যে একটি অ্যারে শুধু **`number`** টাইপের মান ধারণ করবে, তাহলে আপনি নিচের মতো টাইপ ডিক্লেয়ারেশন ব্যবহার করতে পারেন।

---

### **1. `number[]` - অ্যারে টাইপ ডিক্লেয়ারেশন**
এই সিনট্যাক্স দিয়ে আপনি যে অ্যারে ব্যবহার করবেন, সেই অ্যারের প্রতিটি উপাদান `number` টাইপের হবে। যেমন:

```typescript
let numbers: number[] = [1, 2, 3, 4, 5];
```

এখানে `numbers` একটি অ্যারে যার প্রতিটি উপাদান একটি **সংখ্যা (number)**।

---

### **2. `Array<number>` - আরও একটি উপায়**
এছাড়াও, আপনি এই সিনট্যাক্সটি ব্যবহার করতে পারেন:

```typescript
let numbers: Array<number> = [1, 2, 3, 4, 5];
```

এটি **`number[]`** এর সমান এবং একই মানে প্রকাশ করে। অর্থাৎ, অ্যারের প্রতিটি উপাদান একটি **সংখ্যা (number)** হবে।

---

### **অন্য টাইপের অ্যারে**

TypeScript-এ, অ্যারে টাইপ শুধু `number` নয়, যেকোনো টাইপের হতে পারে। নিচে কিছু উদাহরণ দেয়া হলো:

- **`string[]`**: যেখানে সব মান স্ট্রিং হবে।
```typescript
let names: string[] = ["Alice", "Bob", "Charlie"];
```

- **`boolean[]`**: যেখানে সব মান বুলিয়ান (true/false) হবে।
```typescript
let isActive: boolean[] = [true, false, true];
```

এছাড়া, আপনি যে কোনো টাইপের অ্যারে তৈরি করতে পারেন, যেমন:

```typescript
let mixedArray: (string | number)[] = [1, "Hello", 42, "World"];
```

এখানে `mixedArray` অ্যারেটি এমন একটি অ্যারে, যেটির ভিতরে স্ট্রিং এবং সংখ্যা উভয়ই থাকতে পারে।

---

### **Array-এ ডেটা সন্নিবেশ এবং অ্যাক্সেস**
একবার টাইপ ডিফাইন করে দিলে, আপনি অ্যারের ভিতরে ডেটা রাখতে পারবেন এবং সেই ডেটার সাথে কাজ করতে পারবেন।

**অ্যারে ডেটা সন্নিবেশ** (Insert data):
```typescript
let numbers: number[] = [1, 2, 3];
numbers.push(4); // অ্যারে-তে ৪ যোগ হবে।
console.log(numbers); // [1, 2, 3, 4]
```

**অ্যারে ডেটা অ্যাক্সেস** (Access data):
```typescript
let numbers: number[] = [1, 2, 3];
console.log(numbers[0]); // 1
console.log(numbers[2]); // 3
```

এখানে `numbers[0]` দিয়ে প্রথম উপাদান এবং `numbers[2]` দিয়ে তৃতীয় উপাদান অ্যাক্সেস করা হয়েছে।

---

### **`[number]` vs `number[]`**
অনেক সময় নতুন TypeScript ব্যবহারকারীরা `number[]` এবং `[number]` এর মধ্যে পার্থক্য বুঝতে পারে না। এখানে একটি স্পষ্ট পার্থক্য রয়েছে:

- **`number[]`**: এটি একটি অ্যারে, যেখানে প্রতিটি উপাদান `number` টাইপের হবে।
  
```typescript
let numbers: number[] = [1, 2, 3, 4];  // অ্যারে, যেখানে সব উপাদান number টাইপের।
```

- **`[number]`**: এটি একটি **Tuple** টাইপ। `Tuple` হলো এমন একটি ডেটা স্ট্রাকচার যেখানে নির্দিষ্ট সংখ্যক উপাদান থাকে, এবং প্রত্যেকটি উপাদান আলাদা টাইপের হতে পারে।

```typescript
let tuple: [number] = [1];  // এটি একটি Tuple, যেখানে শুধুমাত্র একটিই number উপাদান থাকবে।
```

 `number[]` হলো একটি অ্যারে, যেখানে একাধিক `number` থাকতে পারে। কিন্তু `[number]` হলো একটি `tuple`, যেখানে ঠিক একটিই `number` থাকবে।

---


- **`number[]`**: অ্যারে যা শুধুমাত্র `number` টাইপের মান ধারণ করতে পারে।
- **`Array<number>`**: উপরের সিনট্যাক্সের আরেকটি রূপ, যা একই মানে প্রকাশ করে।
- TypeScript-এ আপনি বিভিন্ন ধরনের অ্যারে তৈরি করতে পারবেন, যেমন: `string[]`, `boolean[]`, `Array<string>`, ইত্যাদি।
- অ্যারে টাইপের সাথে সঠিকভাবে কাজ করতে `push()`, `pop()`, এবং অন্যান্য অ্যারে মেথড ব্যবহার করা যায়।

এভাবে TypeScript-এ অ্যারে টাইপ দিয়ে আপনি আপনার কোডকে আরো টাইপ সেফ ও নির্ভরযোগ্য করতে পারবেন।



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
### TypeScript-এ **Tuple** ব্যাখ্যা

**Tuple** হল এমন একটি ডেটা স্ট্রাকচার যা একটি নির্দিষ্ট সংখ্যক উপাদান ধারণ করে, যেখানে প্রতিটি উপাদান আলাদা টাইপের হতে পারে। এটি অ্যারে থেকে আলাদা, কারণ অ্যারে সাধারণত একই টাইপের মান ধারণ করে (যেমন `number[]` বা `string[]`), কিন্তু Tuple-এ বিভিন্ন টাইপের মান থাকতে পারে।

---

### **Tuple কী?**

- Tuple একটি অ্যারে-সদৃশ ডেটা স্ট্রাকচার।
- Tuple-এ প্রতিটি উপাদান নির্দিষ্ট টাইপের হতে হবে, এবং সংখ্যা (length) নির্দিষ্ট থাকে।
- Tuple তৈরি করার সময়, প্রতিটি উপাদানের টাইপ নির্ধারণ করা হয়।

### **Tuple তৈরি করা**

TypeScript-এ Tuple তৈরি করতে আপনাকে যে সিনট্যাক্স ব্যবহার করতে হবে, তা হল:

```typescript
let tupleName: [Type1, Type2, ...];
```

এখানে, `Type1`, `Type2`, ইত্যাদি হলো টুপলের প্রতিটি উপাদানের টাইপ। টাইপগুলো সাজানো থাকবে এবং নির্দিষ্ট অবস্থানে প্রতিটি উপাদান থাকতে হবে।

---

### **Tuple এর উদাহরণ**

1. **বেসিক Tuple:**

```typescript
let person: [string, number] = ["Alice", 25];
```

এখানে `person` একটি Tuple, যেখানে প্রথম উপাদান একটি `string` (নাম) এবং দ্বিতীয় উপাদান একটি `number` (বয়স)। এটি টাইপ অনুযায়ী সঠিকভাবে ডিফাইন করা হয়েছে।

---

2. **বিভিন্ন ধরনের ডেটা টাইপের Tuple:**

```typescript
let employee: [string, number, boolean] = ["John", 30, true];
```

এখানে, `employee` Tuple-এ তিনটি উপাদান রয়েছে:
- প্রথমটি একটি `string` (নাম),
- দ্বিতীয়টি একটি `number` (বয়স),
- তৃতীয়টি একটি `boolean` (যেমন: কর্মরত কিনা)।

---

### **Tuple-এর সুবিধা**

1. **বিভিন্ন টাইপের মান সংরক্ষণ:** Tuple ব্যবহার করে আপনি একসাথে বিভিন্ন ধরনের মান (যেমন, `string`, `number`, `boolean`) একটি একক ডেটা স্ট্রাকচারে রাখতে পারেন।
   
2. **টাস্ক-ভিত্তিক ব্যবহার:** আপনি Tuple ব্যবহার করতে পারেন যখন আপনার কাছে একটি নির্দিষ্ট সিকোয়েন্সে টাইপ-কনজয়েন্ড উপাদান থাকে, এবং প্রতিটি উপাদান ভিন্ন ধরনের।

---

### **Tuple এর ডেটা অ্যাক্সেস**

Tuple-এর উপাদান অ্যাক্সেস করার জন্য আপনি সাধারণ অ্যারে মতই ইনডেক্স ব্যবহার করতে পারেন:

```typescript
let person: [string, number] = ["Alice", 25];
console.log(person[0]); // "Alice"
console.log(person[1]); // 25
```

এখানে, `person[0]` প্রথম উপাদান (`string` টাইপ) এবং `person[1]` দ্বিতীয় উপাদান (`number` টাইপ)।

---

### **Tuple এর Length:**

Tuple-এ উপাদানের সংখ্যা ঠিক করা থাকে, অর্থাৎ আপনি নির্দিষ্ট সংখ্যক উপাদান ছাড়া অন্য কিছু রাখতে পারবেন না:

```typescript
let person: [string, number] = ["Alice", 25];
person.push("New York"); // Error: Tuple type '[string, number]' of length '2' has no element at index '2'.
```

এখানে, `person` Tuple-এ দুটি উপাদান থাকতে পারে, তৃতীয় উপাদান যোগ করার চেষ্টা করলে TypeScript ত্রুটি দেখাবে।

---

### **Tuple এর সঠিক টাইপ অনুমান**

TypeScript স্বয়ংক্রিয়ভাবে Tuple-এর টাইপ অনুমান করতে পারে, তবে আপনি যদি নিজে টাইপ ডিফাইন করতে চান, তাহলে সেটি নিচের মতো করবেন:

```typescript
let student: [string, number, string] = ["Bob", 21, "Math"];
```

এখানে `student` Tuple-এ তিনটি উপাদান রয়েছে:
1. প্রথম উপাদান হল `string` (নাম),
2. দ্বিতীয় উপাদান হল `number` (বয়স),
3. তৃতীয় উপাদান হল `string` (কোর্সের নাম)।

---

### **Tuple এর আরও কিছু বিশেষত্ব**

1. **Optional Tuple Elements:**

TypeScript-এ Tuple-এর মধ্যে কিছু উপাদান ঐচ্ছিক (optional) হতে পারে। যদি আপনি একটি নির্দিষ্ট স্থান ঠিক করে ঐচ্ছিক উপাদান রাখতে চান, তাহলে `?` চিহ্ন ব্যবহার করতে পারেন।

```typescript
let product: [string, number, string?] = ["Laptop", 500, "Dell"];
```

এখানে, তৃতীয় উপাদান (প্রস্তুতকারক নাম) ঐচ্ছিক, এবং আপনি চাইলে তা বাদ দিতে পারেন।

2. **Rest Parameters in Tuple:**

আপনি Tuple-এ rest parameter ব্যবহার করতে পারেন, যেখানে অনেকগুলো মান রাখা যেতে পারে।

```typescript
let data: [string, ...number[]] = ["Data", 10, 20, 30];
```

এখানে, প্রথম উপাদান একটি `string`, এবং তারপরে যেকোনো সংখ্যক `number` থাকতে পারে।

---

### **Tuple এবং Array-এর পার্থক্য:**

- **Tuple**: নির্দিষ্ট সংখ্যা এবং টাইপের উপাদান থাকে।
- **Array**: সব উপাদান একই টাইপের হতে পারে (যেমন `number[]` বা `string[]`)।

#### উদাহরণ:
```typescript
let arr: number[] = [1, 2, 3]; // Array with only numbers
let tup: [string, number] = ["Alice", 25]; // Tuple with specific types and specific length
```

---



- **Tuple** হলো একটি ডেটা স্ট্রাকচার যেখানে আপনি একাধিক ধরনের উপাদান রাখতে পারেন এবং তাদের সংখ্যা নির্দিষ্ট থাকে।
- Tuple-এ প্রতিটি উপাদানের টাইপ এবং সংখ্যার সীমা স্পষ্টভাবে নির্ধারণ করা যায়।
- TypeScript-এ Tuple ব্যবহার করলে আপনি টাইপ সেফটি বজায় রেখে ডেটা সংরক্ষণ এবং ম্যানিপুলেট করতে পারবেন।

এভাবে **Tuple** ব্যবহার করে TypeScript-এ আপনি আরও নির্ভুল এবং টাইপ সেফ কোড লিখতে পারবেন।

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------

### TypeScript-এ `any` টাইপের ব্যাখ্যা

**`any`** টাইপ TypeScript-এ এমন একটি বিশেষ টাইপ যা ব্যবহার করা হয় যখন আপনি চান না কোনো নির্দিষ্ট মানের জন্য টাইপ চেকিং ত্রুটি ঘটুক। এটি মূলত টাইপ সেফটি থেকে মুক্তি দেয় এবং আপনার কোডে যেকোনো মানের জন্য টাইপ চেকিং আর কার্যকরী হয় না।

---

### **`any` টাইপ কী?**

- যখন কোনো মানের টাইপ `any` হয়, তখন সেই মানের সাথে আপনি যেকোনো ধরণের অপারেশন করতে পারেন।
- `any` টাইপ মানের ওপর কোনো টাইপ চেকিং আর কার্যকরী হবে না, অর্থাৎ, আপনি এর কোনো প্রপার্টি অ্যাক্সেস করতে, সেট করতে, অথবা এটিকে যেকোনো টাইপের মানে অ্যাসাইন করতে পারবেন।
- এটি TypeScript-এর জন্য একটি "পালিয়ে যাওয়ার" রাস্তা, যেখানে আপনি টাইপ চেকিং নিয়ে ভাবতে চান না এবং মনে করেন যে, কোডটি সঠিকভাবে কাজ করবে।

---

### **`any` টাইপ ব্যবহার উদাহরণ**

```typescript
let obj: any = { x: 0 };

// নিচের সবগুলো লাইন কোনো ত্রুটি ছাড়াই কাজ করবে।
obj.foo();  // কোনো ত্রুটি হবে না, কারণ obj এর টাইপ `any`।
obj();      // obj কে ফাংশন হিসেবে কল করা সম্ভব।
obj.bar = 100;  // obj এর নতুন প্রপার্টি bar যোগ করা সম্ভব।
obj = "hello";  // obj কে এখন একটি string মান দেওয়া হয়েছে, তাও কাজ করবে।
const n: number = obj;  // obj কে number টাইপের একটি ভেরিয়েবলে অ্যাসাইন করা হয়েছে।
```

এখানে `obj` এর টাইপ `any` দেওয়ার কারণে, TypeScript কোনো টাইপ চেকিং করবে না। অর্থাৎ, আপনি `obj` দিয়ে যেকোনো কাজ করতে পারেন, এবং TypeScript এই কাজগুলোতে কোনো ত্রুটি দেখাবে না।

---

### **কেন `any` টাইপ ব্যবহার করা হয়?**

1. **টাইপ চেকিং এর দরকার নেই:** কখনো কখনো আপনি টাইপ চেকিং চান না, যেমন যখন আপনার কোড অনেক বেশি জেনেরিক বা ডাইনামিক হয়।
   
2. **মাইগ্রেশন বা এক্সটার্নাল লাইব্রেরি:** যদি আপনি TypeScript-এ JavaScript কোড ট্রান্সপাইল করেন বা কোনো লাইব্রেরি ব্যবহার করেন যার টাইপ ডেফিনেশন নেই, তবে `any` ব্যবহার করা সহজ হতে পারে। এটি টাইপ চেকিং সমস্যাগুলি এড়িয়ে যেতে সাহায্য করে।

3. **ডাইনামিক ডেটা:** যখন আপনি জানেন যে ডেটা টাইপ পরিবর্তিত হতে পারে এবং আপনি সেটির সাথে টাইপ চেকিং করতে চান না, তখন `any` সাহায্য করতে পারে।

---

### **`any`-এর বিপদ এবং সতর্কতা**

`any` টাইপ ব্যবহার করলে কিছু সমস্যা হতে পারে:
- **টাইপ সেফটি হারানো:** `any` ব্যবহার করে আপনি টাইপ সেফটির সুবিধা হারিয়ে ফেলেন, কারণ আপনি TypeScript-এর টাইপ চেকিং ক্ষমতা অক্ষম করছেন।
- **বাগ বা ভুল বৃদ্ধি:** `any` ব্যবহার করার মাধ্যমে আপনি ভুলবশত কোনো ভুল কাজ করতে পারেন, কারণ টাইপ চেকিং আর কাজ করছে না।
  
যতটা সম্ভব `any` টাইপ ব্যবহার এড়িয়ে চলা উচিত। যদি এটি ব্যবহার করা হয়, তবে নিশ্চিত হন যে কোডে কোনো বাগ বা ভুলের সম্ভাবনা কম। সাধারণত, সুনির্দিষ্ট টাইপগুলো ব্যবহার করলে টাইপ সেফটি বজায় থাকে এবং বাগ কম হয়।

---

### **`any` টাইপের বিকল্প:**

- **`unknown` টাইপ:** `unknown` টাইপ `any` এর মতো, তবে এটি আরো সুরক্ষিত। যখন কোনো ভেরিয়েবলের টাইপ `unknown` হয়, তখন আপনি সেটির সাথে কাজ করার আগে টাইপ চেকিং করতে পারবেন।
  
  উদাহরণ:
  ```typescript
  let value: unknown = 10;
  // এটি ত্রুটি দিবে:
  const result: string = value; // Error: Type 'unknown' is not assignable to type 'string'.
  ```

- **`void` এবং `never`:** আপনি যখন কোনো ফাংশন বা মানে কোনো রিটার্ন চান না, তখন `void` বা `never` টাইপ ব্যবহার করতে পারেন। তবে, এগুলো `any` থেকে আলাদা।

---



- **`any` টাইপ** TypeScript-এ একটি বিশেষ টাইপ যা টাইপ চেকিংকে এড়িয়ে যায় এবং যে কোনো মানের সাথে যেকোনো অপারেশন করতে দেয়।
- এটি ব্যবহার করলে টাইপ সেফটি হারিয়ে যায়, তবে কিছু নির্দিষ্ট পরিস্থিতিতে এটি উপকারী হতে পারে।
- `any` টাইপের পরিবর্তে **`unknown`** বা অন্যান্য নির্দিষ্ট টাইপ ব্যবহার করলে আরও সুরক্ষিত কোড লেখা সম্ভব।






----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
