**TypeScript এ Union Types** 
TypeScript এ **Union Types** এমন একটি ধারণা যেখানে আপনি দুটি বা তার অধিক টাইপকে একত্রিত করে নতুন একটি টাইপ তৈরি করতে পারেন। এটি এমন টাইপ তৈরি করে যা একাধিক টাইপের যে কোন একটি হতে পারে। এটি খুবই শক্তিশালী, কারণ একে ব্যবহার করে আপনি ফাংশন বা ভ্যারিয়েবলে একাধিক টাইপের মান গ্রহণ করতে পারেন।

### Union Type কি?

যখন আপনি **Union Type** ব্যবহার করেন, তখন আপনি দুইটি বা তার অধিক টাইপকে একত্রিত করেন, যার মানে হল যে সেই টাইপের ভ্যারিয়েবল বা ফাংশন সেই সমস্ত টাইপের যেকোনো একটির মান ধারণ করতে পারে। এটি সাধারণত `|` (OR) অপারেটর দ্বারা চিহ্নিত করা হয়।

### Union Type উদাহরণ

ধরা যাক, আপনি একটি ফাংশন লিখতে চান যা একটি ID মান গ্রহণ করবে এবং এটি হয় একটি **number** বা **string** হতে পারে। তাহলে আপনি একটি **Union Type** ব্যবহার করতে পারেন।

```typescript
function printId(id: number | string) {
  console.log("Your ID is: " + id);
}

// ঠিক আছে
printId(101);    // এখানে একটি number পাঠানো হয়েছে
printId("202");   // এখানে একটি string পাঠানো হয়েছে

// ভুল
printId({ myID: 22342 });   // এখানে একটি অবজেক্ট পাঠানো হয়েছে, যা number বা string নয়
```

এখানে `id: number | string` মানে হল যে ফাংশনটি দুটি টাইপের যেকোনো একটি গ্রহণ করবে: `number` অথবা `string`। কিন্তু যদি আপনি অন্য কোনো টাইপ (যেমন `{ myID: 22342 }`) পাঠান, তাহলে TypeScript এটি গ্রহণ করবে না, এবং একটি ত্রুটি দেখাবে।

### Union Type এর বৈশিষ্ট্য

- **যেকোনো একটি টাইপ হতে পারে:** আপনি যখন Union Type ব্যবহার করেন, তখন এটি মানে হল যে একটি ভ্যারিয়েবল বা প্যারামিটার যেকোনো একটি টাইপের মান ধারণ করতে পারে। এখানে `number | string` এর অর্থ হল ভ্যারিয়েবলটি হয় সংখ্যা (number) অথবা স্ট্রিং (string) হতে পারে।

- **অফসেটও থাকতে পারে:** Union Type-এর মধ্যে একাধিক টাইপ থাকতে পারে। আপনি চাইলে আরও অনেক টাইপ একসাথে যোগ করতে পারেন, যেমন:

```typescript
function printTextOrNumberOrBool(
  textOrNumberOrBool: string | number | boolean
) {
  console.log(textOrNumberOrBool);
}
```

এখানে `textOrNumberOrBool` প্যারামিটারটি `string`, `number`, অথবা `boolean` টাইপের যেকোনো একটি মান গ্রহণ করতে পারে।

### Union Types এর সুবিধা

1. **উপলব্ধতা বৃদ্ধি:** আপনি যদি জানেন যে একটি ভ্যারিয়েবল বা ফাংশন একাধিক ধরনের মান ধারণ করতে পারে, তবে Union Types ব্যবহার করলে আপনি সেই ভ্যারিয়েবলটি আরও ফ্লেক্সিবলভাবে ব্যবহার করতে পারবেন।

2. **টাইপ সুরক্ষা:** TypeScript আপনার কোডে টাইপ চেকিং করবে, যাতে ভুল টাইপ দেওয়া হলে আপনি ত্রুটি পান এবং কোড আরো নির্ভুল হয়।

3. **সহজ সমন্বয়:** Union Types আপনার কোডে বিভিন্ন ধরনের ডেটা একত্রিত করার সুবিধা প্রদান করে, যাতে আপনি আরও পরিষ্কার ও শক্তিশালী ফাংশন তৈরি করতে পারেন।



- **Union Type** হল TypeScript-এর একটি শক্তিশালী ফিচার যা আপনাকে একাধিক টাইপ একত্রিত করে একটি টাইপ তৈরি করার সুযোগ দেয়।
- এটি আপনাকে বিভিন্ন টাইপের মান একটি ভ্যারিয়েবল বা ফাংশনে গ্রহণ করার সুযোগ দেয়, যেমন `number | string` বা `string | number | boolean`।
- **Type Safety** রক্ষা করতে TypeScript এই টাইপ চেকিং সঠিকভাবে করে, যাতে কোডের মধ্যে ভুল টাইপ ব্যবহারের ক্ষেত্রে ত্রুটি দেখা যায়।

এভাবে, **Union Types** ব্যবহার করে আপনি TypeScript এ আরো ফ্লেক্সিবল এবং নিরাপদ কোড লিখতে পারেন।

----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------
### **Union Types এ কাজ করা** (Working with Union Types)

TypeScript-এ **Union Types** ব্যবহার করা সহজ, কারণ আপনি শুধুমাত্র যেকোনো একটি সদস্যের সাথে মেলে এমন টাইপ প্রদান করলে হবে। যেমন যদি আপনার কাছে একটি `number | string` টাইপের ভ্যারিয়েবল থাকে, তবে আপনি সেই ভ্যারিয়েবলটি `number` অথবা `string` যেকোনো একটির মান দিয়ে সেট করতে পারবেন।

তবে, Union Types এর সাথে কাজ করার কিছু নির্দিষ্ট নিয়ম রয়েছে যা আপনাকে জানতে হবে। চলুন দেখে নেওয়া যাক কীভাবে Union Types এর মানগুলির সাথে নিরাপদে কাজ করা যায়।

---

### **Union Type-এর মানের সাথে কাজ করা**

যদি আপনার কাছে একটি **Union Type** হয়, যেমন `number | string` এবং আপনি সেই টাইপের ভ্যারিয়েবলটির সাথে কিছু অপারেশন করতে চান, TypeScript তখন শুধুমাত্র সেই অপারেশনগুলোকেই অনুমতি দিবে, যেগুলো ঐ Union Type-এর **প্রতিটি সদস্য**-এর জন্য বৈধ।

#### **যেমন:**

```typescript
function printId(id: number | string) {
  console.log(id.toUpperCase()); // এই লাইনে ত্রুটি হবে
}
```

এখানে, আমরা `id.toUpperCase()` কল করছি, কিন্তু **`toUpperCase()`** শুধুমাত্র **string** টাইপের উপর কাজ করে, **number** টাইপের উপরে নয়। সুতরাং, TypeScript এটি অনুমতি দেবে না এবং একটি ত্রুটি দেবে:

```
Property 'toUpperCase' does not exist on type 'string | number'.
```

#### **এটি সমাধান করা: Narrowing ব্যবহার করা**

সমাধান হচ্ছে Union Type-এর মানকে **narrow** (সঙ্কুচিত) করা, যাতে TypeScript জানে কোন টাইপের সাথে কাজ করছে। Narrowing হচ্ছে একটি প্রক্রিয়া, যেখানে TypeScript কোডের কাঠামো দেখে কোন একটি টাইপ সুনির্দিষ্টভাবে নির্ধারণ করতে পারে।

#### **উদাহরণ:**

```typescript
function printId(id: number | string) {
  if (typeof id === "string") {
    // এখানে, id শুধু string টাইপ হবে
    console.log(id.toUpperCase());
  } else {
    // এখানে, id number টাইপ হবে
    console.log(id);
  }
}
```

এখানে `typeof id === "string"` ব্যবহার করা হয়েছে, যা TypeScript-কে বলে দেয় যে `id` যদি **string** টাইপ হয়, তবে আমরা `toUpperCase()` ব্যবহার করতে পারি। যদি তা না হয়, তখন `id` টাইপ হবে **number**, এবং আমরা সেক্ষেত্রে শুধু `console.log(id)` ব্যবহার করব।

---

### **Array.isArray() ব্যবহার করে Narrowing**

আরেকটি উদাহরণ হতে পারে, **Array.isArray()** ফাংশন ব্যবহার করা:

```typescript
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // এখানে, 'x' টাইপ হবে 'string[]'
    console.log("Hello, " + x.join(" and "));
  } else {
    // এখানে, 'x' টাইপ হবে 'string'
    console.log("Welcome lone traveler " + x);
  }
}
```

এখানে, `Array.isArray(x)` ব্যবহার করে TypeScript জানে যে `x` যদি একটি অ্যারে হয়, তবে এটি `string[]` টাইপ হবে। আর যদি তা না হয়, তবে এটি `string` টাইপ হবে, তাই আমাদের কিছু আলাদা কাজ করতে হবে না।

---

### **সব সদস্যের মধ্যে সাধারণ গুণাবলী থাকা**

অনেক সময় Union Types-এর সব সদস্যের মধ্যে কিছু সাধারণ বৈশিষ্ট্য থাকে। উদাহরণস্বরূপ, **arrays** এবং **strings** উভয়েরই `slice` নামক মেথড রয়েছে। তাই, যদি আপনি একটি Union Type ব্যবহার করেন, যেখানে সকল সদস্যেরই সাধারণ কোনো বৈশিষ্ট্য থাকে, তাহলে আপনি **narrowing** ছাড়া সেই বৈশিষ্ট্যটি ব্যবহার করতে পারবেন।

#### **উদাহরণ:**

```typescript
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3);
}
```

এখানে, `x.slice(0, 3)` ব্যবহার করা হয়েছে এবং এটি `number[]` বা `string` যেকোনো টাইপের জন্য কাজ করবে, কারণ **`slice`** মেথড উভয় টাইপের জন্য বৈধ। TypeScript স্বয়ংক্রিয়ভাবে এটি অনুমতি দেয় কারণ `slice` মেথডটি **array** এবং **string** উভয়ের জন্য বৈধ।

---

### **Union Types এবং Intersection of Properties**

একটি Union Type এ উপস্থিত প্রতিটি সদস্যের মধ্যে কিছু সাধারণ বৈশিষ্ট্য থাকতে পারে, এবং এটি ভুল বোঝাবুঝির কারণ হতে পারে। Union Types তৈরি করার সময় আপনি যেহেতু একাধিক টাইপের সাথে কাজ করছেন, তাই এটি মনে হতে পারে যে সমস্ত টাইপের বৈশিষ্ট্যগুলো একসাথে চলে এসেছে, যা আসলে সত্য নয়।

একটি উদাহরণ:

ধরা যাক, দুটি সেট আছে:
- এক সেটে "টাল" (tall) মানুষ রয়েছে, যারা হ্যাট পরে।
- আরেক সেটে "স্প্যানিশ ভাষী" মানুষ রয়েছে, যারা হ্যাট পরে।

এখন, যদি আমরা এই দুটি সেট একত্রিত করি, তাহলে কেবলমাত্র যে তথ্যটি নিশ্চিতভাবে জানা যাবে, তা হল **"সবাই হ্যাট পরে"**।

এভাবেই Union Types কাজ করে — এটি প্রতিটি টাইপের একটি সাধারণ বৈশিষ্ট্য নেয় এবং তার উপর ভিত্তি করে কাজ করে।

---



- **Union Types** হলো টাইপের একত্রিত সংস্করণ, যা আপনাকে একাধিক টাইপের মান গ্রহণ করার সুবিধা দেয়।
- TypeScript তখনই কোনো অপারেশন অনুমতি দেয়, যখন তা Union Type-এর প্রতিটি সদস্যের জন্য বৈধ।
- **Narrowing** ব্যবহার করে, আপনি টাইপটি আরও সুনির্দিষ্ট করতে পারেন এবং TypeScript কে সাহায্য করতে পারেন এটি জানাতে যে কোন টাইপের মান ব্যবহার করা হচ্ছে।
- কিছু সময়, Union Type-এর সদস্যের মধ্যে সাধারণ বৈশিষ্ট্য থাকতে পারে, যা narrowing ছাড়াই ব্যবহার করা যায়।
  
এভাবে, Union Types আপনার কোডে ফ্লেক্সিবিলিটি যোগ করে, তবে সঠিকভাবে narrowing ব্যবহার করা প্রয়োজন যাতে কোড সঠিকভাবে কাজ করে।




----------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------


