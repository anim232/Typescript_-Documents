### ১. JavaScript এর ভ্যালু ও অপারেশন

প্রথমে বলা হয়েছে যে, **JavaScript** এ প্রতিটি ভ্যালুর কিছু নির্দিষ্ট আচরণ থাকে, যেগুলো আপনি বিভিন্ন অপারেশন চালিয়ে পর্যবেক্ষণ করতে পারেন। তবে, এটি যদি পুরোপুরি অদ্ভুত মনে হয়, তবে নিচের উদাহরণটি দেখুন:

```javascript
message.toLowerCase();
message();
```

এখানে `message` একটি ভ্যারিয়েবল, এবং আপনি দুটি অপারেশন প্রয়োগ করতে চান:

- প্রথম লাইনে, `message.toLowerCase()` ব্যবহৃত হচ্ছে, যা `message` ভ্যালুর `toLowerCase` প্রপার্টি অ্যাক্সেস করছে এবং তারপর সেটি কল করছে। যদি `message` একটি স্ট্রিং হয়, এটি স্ট্রিংটিকে ছোট হাতের অক্ষরে রূপান্তর করবে।
  
- দ্বিতীয় লাইনে, `message()` কল করার চেষ্টা করা হচ্ছে, যা একটা ফাংশন হিসেবে ব্যবহার হচ্ছে। তবে, যদি `message` একটি স্ট্রিং হয়, তখন এটি ফাংশন হিসেবে কাজ করবে না এবং JavaScript একটি `TypeError` দিবে: **"message is not a function"**।

### ২. `message` এর আচরণ জানার সমস্যা

এখানে, মূল সমস্যা হল যে, আপনি জানেন না `message` কী ধরনের ভ্যালু, তাই আপনার কোডের আচরণ কী হবে তা পূর্বানুমান করা কঠিন। যদি `message` একটি স্ট্রিং হয়, তাহলে `toLowerCase` কাজ করবে কিন্তু `message()` কল করলে এরর দিবে। 

প্রশ্নগুলো হল:

- **`message` কি callable?**
- **এতে `toLowerCase` প্রপার্টি আছে কি?**
- **`toLowerCase` কি callable?**
  
আপনি যদি জানতেন যে `message` একটি স্ট্রিং, তাহলে আপনি জানতেন `toLowerCase` কাজ করবে, কিন্তু কল করা যাবে না।

### ৩. JavaScript এ টাইপ চেকিং এবং ডাইনামিক টাইপিং

JavaScript এ টাইপ চেকিং ডাইনামিক। এর মানে হল, কোড রান করার সময়, JavaScript `message` এর টাইপ বুঝে তার আচরণ নির্ধারণ করে। উদাহরণ হিসেবে:

```javascript
const message = "Hello World!";
message.toLowerCase();  // সঠিক কাজ করবে
message();  // TypeError: message is not a function
```

এখানে JavaScript টাইপ চেক করে এবং স্ট্রিং টাইপের জন্য `message()` কল করতে দেয় না। তবে আপনি JavaScript এ সরাসরি টাইপ চেক করতে পারেন **`typeof`** অপারেটর ব্যবহার করে:

```javascript
typeof message;  // "string"
```

কিন্তু এটি সব ধরনের ভ্যালুর জন্য সহায়ক নয়, যেমন ফাংশন বা আরও জটিল অবজেক্টস।

### ৪. ফাংশন এবং টাইপ নির্ধারণের সমস্যা

ধরা যাক, একটি ফাংশন রয়েছে:

```javascript
function fn(x) {
  return x.flip();
}
```

এখানে `flip()` প্রপার্টি থাকা কোনো অবজেক্ট যদি `fn` ফাংশনে পাঠানো হয়, তাহলে এটি সঠিকভাবে কাজ করবে। কিন্তু JavaScript এ আপনি runtime এর সময় জানবেন না, যে কোন অবজেক্টে `flip()` রয়েছে বা নেই। 

এটি JavaScript এর ডাইনামিক টাইপিং এর একটি সমস্যা, কারণ আপনাকে কোড রান করার সময়ই বুঝতে হবে। কোড লেখার সময় এরকম আচরণ সম্পর্কে পূর্বানুমান করা কঠিন।

### ৫. স্ট্যাটিক টাইপ সিস্টেম এবং TypeScript

এখানে মূল কথা হচ্ছে যে, **JavaScript** এর ডাইনামিক টাইপিং আমাদের ভুল থেকে সতর্ক থাকতে সাহায্য করে না। কোড রান না করেই কোন ভুল ধরতে পারা কঠিন, এবং তা আসলে বড় সমস্যা হয়ে দাঁড়াতে পারে।

এখানে **TypeScript** এর ভূমিকা উঠে আসে। TypeScript একটি **স্ট্যাটিক টাইপ সিস্টেম** ব্যবহার করে। এর মাধ্যমে আপনি কোড লেখার সময়ই জানতে পারেন যে, কোন ভ্যালু কি ধরনের আচরণ করবে। TypeScript কোড চালানোর আগে ত্রুটি জানিয়ে দেয়, যাতে আপনি আগে থেকেই বুঝতে পারেন কোথায় ভুল হতে পারে।

### ৬. উদাহরণ

এখন, ধরুন আপনি এই কোডটি TypeScript এ লিখছেন:

```typescript
const message = "hello!";
message();  // TypeScript ত্রুটি দিবে যে message একটি স্ট্রিং এবং এটি কল করা যাবে না
```

TypeScript এর মাধ্যমে আপনাকে জানানো হবে যে, `message` একটি স্ট্রিং এবং এটি কল করা যাবে না, তাই ত্রুটি ঘটবে। 

এখানে TypeScript মূলত স্ট্যাটিক টাইপ চেকিং করছে, যা আমাদের কোড চালানোর আগেই এই ত্রুটিগুলো খুঁজে বের করতে সহায়তা করে।



- JavaScript এ ডাইনামিক টাইপিং থাকায়, কোড চালানোর আগে বুঝতে পারা কঠিন কী হবে।
- TypeScript এর স্ট্যাটিক টাইপ সিস্টেম আমাদের কোডে টাইপ সংক্রান্ত ভুলগুলো চালানোর আগে ধরতে সাহায্য করে।
- TypeScript এর মাধ্যমে আমরা টাইপ এবং আচরণের পূর্বানুমান করতে পারি এবং কোডে ত্রুটি থেকে আগে থেকেই সাবধান থাকতে পারি। 

এভাবে, JavaScript এর ডাইনামিক টাইপিং এবং TypeScript এর স্ট্যাটিক টাইপ চেকিং এর মধ্যে মৌলিক পার্থক্যটি বোঝা গেল।

#####



### **Non-Exception Failures (নন-এক্সেপশন ফেলিওরস)**
নন-এক্সেপশন ফেলিওরস এমন পরিস্থিতি, যেখানে **কোনো সরাসরি ত্রুটি (error) ঘটছে না**, কিন্তু কিছু ভুল বা অস্বাভাবিক কিছু ঘটছে যা পরবর্তীতে সমস্যা সৃষ্টি করতে পারে। এর মানে হলো, প্রোগ্রামটি ঠিক মতো চলতে থাকলেও কোনো কিছু ঠিকমতো কাজ করছে না, এবং সেটি পরবর্তীতে সমস্যা তৈরি করতে পারে।

### **JavaScript এ Runtime Errors (রানটাইম এররস)**
JavaScript যখন আপনার কোড রান করছে, তখন কখনও কখনও কিছু ভুল ঘটে। এই ভুলগুলো **runtime error** এর মধ্যে পড়ে। 

যেমন ধরুন, আপনি যদি **কিছু কল করতে চান যা কল করা যাবে না**, তখন JavaScript এক্সেপশন (ত্রুটি) দিবে। 

উদাহরণ হিসেবে, ধরুন:

```javascript
const user = {
  name: "Daniel",
  age: 26,
};
user.location; // এটি undefined রিটার্ন করবে, কোনো ত্রুটি ছাড়াই
```

এখানে `user.location` যখন খোঁজা হচ্ছে, তখন JavaScript কোনো ত্রুটি (error) ছাড়াই **undefined** রিটার্ন করবে। এটি এক ধরনের অস্বাভাবিক আচরণ, কিন্তু কোনো ত্রুটি নিক্ষেপিত হয় না।

### **TypeScript এ ত্রুটি (Error)**
JavaScript এর মতো, **TypeScript** একটি **স্ট্যাটিক টাইপ সিস্টেম**। এর মানে হলো, TypeScript কিছু ভুল ধরতে পারে যা JavaScript runtime-এ ত্রুটি তৈরি করবে না।

উদাহরণ:

```typescript
const user = {
  name: "Daniel",
  age: 26,
};
user.location; // এটি TypeScript এর ত্রুটি সৃষ্টি করবে
```

TypeScript এখানে জানিয়ে দেবে যে `location` প্রপার্টি `user` অবজেক্টে নেই, এবং এটি একটি ত্রুটি দেখাবে:  
**Property 'location' does not exist on type '{ name: string; age: number; }'**

এটি সাহায্য করে ভুলগুলি আগেই ধরতে, যা পরে বড় সমস্যা সৃষ্টি করতে পারে।

### **কিছু সাধারণ ভুলের উদাহরণ**
#### **টাইপো (Typos)**:
কখনও কখনও আপনি ভুল করে কোনো কোডে টাইপ করেন। যেমন:

```javascript
const announcement = "Hello World!";
announcement.toLocaleLowercase(); // ভুল
announcement.toLocalLowerCase(); // ভুল
announcement.toLocaleLowerCase(); // সঠিক
```

এখানে TypeScript এর মাধ্যমে আপনি `toLocalLowerCase` টাইপোর জন্য ত্রুটি দেখতে পারবেন।

#### **ফাংশন কল না করা (Uncalled Functions)**:
ধরা যাক, আপনি একটি ফাংশন ব্যবহার করতে চান, কিন্তু ভুলভাবে সেটি কল করছেন:

```javascript
function flipCoin() {
  return Math.random() < 0.5;
}

flipCoin; // এখানে ফাংশনটি কল করা হয়নি
```

এটি TypeScript এ এমন ত্রুটি তৈরি করবে:

**Operator '<' cannot be applied to types '() => number' and 'number'.**

এখানে, আপনি ফাংশনটি ভুলভাবে ব্যবহার করেছেন, যেটি TypeScript ধরতে পারবে।

#### **বেসিক লজিক্যাল ভুল (Basic Logic Errors)**:
ধরা যাক, আপনি একটি লজিক্যাল ভুল করেছেন:

```javascript
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
  // কিছু কোড
} else if (value === "b") {
  // এটি কখনই চলবে না, কারণ value এর ধরন 'a' অথবা 'b' এর মধ্যে থাকবে
}
```

এখানে, TypeScript একটি সতর্কতা দেখাবে যে এই কোডের মধ্যে লজিক্যাল সমস্যা রয়েছে এবং কিছু কোড কখনও কার্যকর হবে না।

---


```javascript
const value = Math.random() < 0.5 ? "a" : "b";

if (value !== "a") {
  // কিছু কোড
} else if (value === "b") {
  // এটি কখনই চলবে না, কারণ value এর ধরন 'a' অথবা 'b' এর মধ্যে থাকবে
}
```

1. **`value` এর মান:**
   প্রথম লাইনে, আপনি `value` নামে একটি পরিবর্তনশীল তৈরি করছেন, যার মান হবে `"a"` বা `"b"`। এটি `Math.random() < 0.5` এর উপর ভিত্তি করে নির্ধারিত হচ্ছে:
   
   - যদি `Math.random()` 0.5 এর চেয়ে কম হয়, তাহলে `value` হবে `"a"`.
   - অন্যথায়, `value` হবে `"b"`.

   সুতরাং, `value` একমাত্র `"a"` বা `"b"` এর মধ্যে থাকবে। 

2. **যে সমস্যা হতে পারে:**
   পরের কোডে আপনি `value !== "a"` এবং `value === "b"` শর্ত দুটি চেক করছেন। 

   যেহেতু `value` সর্বদা `"a"` অথবা `"b"` এর মধ্যে একটিই হবে, তাই একে একে দুটি শর্তের মধ্যে পরস্পর বিরোধী অবস্থায় পৌঁছানো সম্ভব নয়:

   - যখন `value === "a"` হবে, তখন `value !== "a"` হবে `false`, এবং পরবর্তী `else if (value === "b")` শর্তটি কখনই পরীক্ষা করা হবে না।
   - যখন `value === "b"` হবে, তখন `value !== "a"` হবে `true`, কিন্তু পরবর্তী শর্ত `else if (value === "b")` ঠিক থাকবে, কারণ `value` এর মান `"b"`।

   সুতরাং, এই কোডে আপনার **অপ্রয়োজনীয় বা অপ্রত্যাশিত কোড** আছে। **`else if (value === "b")`** এই শর্তটি কখনও পৌঁছাতে পারবে না যখন `value` `"a"` থাকবে, এবং এটি খুবই বিরক্তিকর কারণ এটি সঠিক লজিকাল চেক তৈরি করে না। এই লজিক্যাল সমস্যা এড়িয়ে চলা উচিত।

### TypeScript কেন সতর্ক করবে?
TypeScript এর **strict type checking** এর কারণে এটি এই ধরনের সমস্যা স্বচालितভাবে ধরতে পারে, এবং আপনার কোডে থাকা **অপ্রয়োজনীয় শর্তগুলোর জন্য** সতর্কবার্তা দিতে পারে।

এটি আপনাকে বলবে:
- **"The condition appears to be unintentional."**
- বা **"This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap."**

### **সঠিক সমাধান:**

যেহেতু `value` একমাত্র `"a"` বা `"b"` হবে, আপনি শুধু একটি শর্ত ব্যবহার করতে পারেন। উদাহরণস্বরূপ:

```javascript
const value = Math.random() < 0.5 ? "a" : "b";

if (value === "a") {
  // value হল "a"
} else {
  // value হল "b"
}
```

এখানে, **`else`** শর্ত ব্যবহার করা হচ্ছে কারণ `value` অন্যথায় `"b"` হবে। এটি আরও সোজাসুজি এবং লজিক্যালভাবে সঠিক। 

এইভাবে, আপনি কোডে অপ্রয়োজনীয় শর্তগুলো বাদ দিতে পারবেন এবং আপনার কোডটি আরো পরিষ্কার ও কার্যকরী হবে।
######

JavaScript নিজে থেকেই কিছু সমস্যাকে শুধুমাত্র **undefined** দিয়ে শেষ করে দেয়, কিন্তু TypeScript সেই সমস্যা গুলোকে **ত্রুটি** হিসেবে চিহ্নিত করে এবং সেগুলোকে আগেই ধরতে সাহায্য করে। এর ফলে আপনি যখন কোড লিখবেন, তখন আপনার কোডের মধ্যে ভুল বা অস্বাভাবিক কিছু থাকলে TypeScript আপনাকে সেটি জানিয়ে দেবে, যাতে আপনি আগেই তা ঠিক করতে পারেন।

এই ধরনের **non-exception failures** যেগুলো JavaScript-runtime এ ত্রুটি হিসেবে দেখায় না, তবে TypeScript এগুলো ধরতে পারে।

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
### **Types for Tooling (টাইপস ফর টুলিং) - TypeScript এর সাহায্যে কোড লেখা সহজতর করা**

TypeScript শুধুমাত্র **বাগ ধরতে** সাহায্য করে না, বরং এটি **আগেই সেগুলো রোধ** করতে পারে। চলুন, এটিকে খুব সহজভাবে ব্যাখ্যা করি।

### **TypeScript এর কাজ কী?**

TypeScript একটি **স্ট্যাটিক টাইপিং ভাষা**, যার মানে হলো TypeScript আপনার কোডের **টাইপস** (যেমন সংখ্যার টাইপ, স্ট্রিং টাইপ, অবজেক্ট টাইপ ইত্যাদি) চেক করে এবং ভুল হলে ত্রুটি (error) দেখায়। এইভাবে, TypeScript আপনাকে **আগেই ভুল ধরতে** সাহায্য করে, যাতে আপনার কোডে কোনো সমস্যা না হয়।

### **TypeScript কি আরও কিছু করতে পারে?**
TypeScript শুধু ত্রুটি দেখানোর মাধ্যমেই থেমে থাকে না, বরং **সম্পূর্ণ কোড লেখার প্রক্রিয়াটিকে আরও স্মার্ট এবং দ্রুত** বানাতে পারে। এটি **টুলিং** (tooling) এর মাধ্যমে কোড লেখার অভিজ্ঞতাকে উন্নত করে। 

### **TypeScript এবং টুলিং**
টুলিং বলতে বুঝায় এমন সব সরঞ্জাম বা ফিচার যা কোড লেখার সময় আমাদের সাহায্য করে। TypeScript একটি **টাইপ চেকার** হিসেবে কাজ করে, এবং এটি **এডিটরে কোড লেখার সময় আমাদের সাহায্য** করতে পারে। এটি আমাদের কোডের **ত্রুটি** চেক করতে পারে, এবং কোন ফাংশন বা প্রপার্টি ব্যবহার করা উচিত, সেটি বলতেও পারে।

### **কিভাবে TypeScript টুলিং কাজ করে?**
ধরা যাক, আপনি `express` লাইব্রেরি ব্যবহার করছেন এবং `app.get` ফাংশনে কিছু কোড লিখছেন। কিন্তু আপনি সঠিকভাবে `res.sen` লিখেছেন। TypeScript এই জায়গায় আপনার ভুল ধরতে পারবে এবং **সঠিক অপশনগুলো দেখাবে**, যেমন: `send`, `sendFile`, `sendStatus` ইত্যাদি। এটি কোড লেখার সময় আপনার জন্য কোড কমপ্লিশন এবং ভুল সংশোধন করে দেবে।

উদাহরণস্বরূপ:

```typescript
import express from "express";
const app = express();

app.get("/", function (req, res) {
  res.sen  // এখানে আপনি ভুল লিখেছেন
         
  // TypeScript সঠিকভাবে পরবর্তী অপশনগুলো দেখাবে:
  // send
  // sendFile
  // sendStatus
});
 
app.listen(3000);
```
### **`express` মডিউলের জন্য TypeScriptন্য টাইপ ডেফিনিশন খুঁজে পাচ্ছে না।**
আপনার যে ত্রুটিটি ঘটছে তা হচ্ছে,  `express` মডিউলের জন্য TypeScriptন্য টাইপ ডেফিনিশন খুঁজে পাচ্ছে না। TypeScript বিভিন্ন লাইব্রেরি বা মডিউলের টাইপস বুঝতে এবং সঠিকভাবে কাজ করতে **ডিক্লারেশন ফাইল** (যেমন `.d.ts` ফাইল) ব্যবহার করে। যদি TypeScript কোনো লাইব্রেরির জন্য ডিক্লারেশন ফাইল না পায়, তবে এটি ঐ লাইব্রেরিকে `any` টাইপ হিসেবে ধরে নেয়, যা টাইপ সেফটি হ্রাস করে।

### **কেন এটি হচ্ছে?**
- TypeScript আপনার প্রকল্পে **`@types/express`** প্যাকেজটি খুঁজে পাচ্ছে না। এই প্যাকেজটি `express` লাইব্রেরির জন্য টাইপ ডিক্লারেশন প্রদান করে।
- যখন TypeScript টাইপ ডিক্লারেশন পায় না, তখন সেটিকে `any` টাইপ হিসেবে ধরে নেয়, যার ফলে টাইপ চেকিং সঠিকভাবে কাজ করে না।

### **সমাধান:**

এই ত্রুটিটি ঠিক করার জন্য আপনাকে **`@types/express`** প্যাকেজটি ইনস্টল করতে হবে।

#### ১. **`@types/express` প্যাকেজ ইনস্টল করুন:**
আপনি নিচের কমান্ডটি চালিয়ে এই প্যাকেজটি ইনস্টল করতে পারেন:

```bash
npm install --save-dev @types/express
```

এটি আপনার প্রজেক্টের **devDependencies** এ **`@types/express`** প্যাকেজটি ইনস্টল করবে, যা `express` এর টাইপ ডেফিনিশন প্রদান করবে।

#### ২. **এটি যদি কাজ না করে:**
যদি আপনি এখনও টাইপ ডিক্লারেশন ফাইল না পেয়ে থাকেন, তাহলে আপনি একটি নতুন `.d.ts` ফাইল তৈরি করে `express` মডিউলের জন্য টাইপ ডিক্লেয়ারেশন যোগ করতে পারেন।

একটি নতুন ফাইল তৈরি করুন, যেমন `express.d.ts` এবং সেখানে লিখুন:

```typescript
declare module 'express';
```

এই পদ্ধতি `express` মডিউলকে `any` টাইপ হিসেবে চিনতে দেবে, কিন্তু এটি সম্পূর্ণভাবে টাইপ সেফ নয়। তবে, এই পদ্ধতি অন্তত TypeScript কে বুঝতে সাহায্য করবে যে এটি একটি মডিউল।


আপনি যদি `express` এর টাইপ ডেফিনিশন পেতে চান এবং সঠিক টাইপ সেফটি ব্যবহার করতে চান, তবে **`@types/express`** প্যাকেজটি ইনস্টল করতে হবে।



এখানে `res.sen` লিখে আপনি ভুল করেছেন। TypeScript আপনার ভুল ধরবে এবং সঠিক ফাংশনগুলো যেমন `send`, `sendFile` ইত্যাদি দেখাবে। 

### **TypeScript কীভাবে আরও সাহায্য করতে পারে?**
1. **কোড কমপ্লিশন (Code Completion):** TypeScript এডিটরের সাথে ইন্টিগ্রেটেড হয়ে কোড কমপ্লিশন অফার করে। যখন আপনি কোনো ফাংশন বা প্রপার্টি লিখতে শুরু করবেন, TypeScript আপনাকে সেই প্রপার্টি বা ফাংশনের সম্ভাব্য নামগুলো দেখাবে।
   
2. **এরর মেসেজ (Error Messages):** TypeScript যেকোনো টাইপ সংক্রান্ত ভুল চিহ্নিত করে ত্রুটি বার্তা দেখাবে। এটি আপনাকে বলবে যে কোথায় এবং কীভাবে ভুল হয়েছে, যাতে আপনি দ্রুত সমস্যার সমাধান করতে পারেন।

3. **কুইক ফিক্সেস (Quick Fixes):** TypeScript সাপোর্টেড এডিটর যেমন VS Code আপনাকে **"Quick Fix"** দেয়। এর মানে হলো, যদি আপনার কোডে কোনো ত্রুটি থাকে, TypeScript আপনাকে সেই ত্রুটিটি **অটোমেটিক্যালি** ঠিক করার জন্য একটি অপশন দেখাবে। আপনি একটি ক্লিকেই আপনার কোড ঠিক করতে পারবেন।

4. **কোড রিফ্যাক্টরিং (Code Refactoring):** TypeScript কোডের গঠন পরিবর্তন করার সময় আপনাকে সাহায্য করতে পারে। যেমন, একটি ফাংশন বা ভ্যারিয়েবল রিনেম করতে হলে TypeScript পুরো প্রোজেক্টের মধ্যে সেই নামের সকল রেফারেন্স পরিবর্তন করে দেবে।

5. **নেভিগেশন (Navigation):** TypeScript এর সাহায্যে আপনি কোডের মধ্যে দ্রুত নেভিগেট করতে পারেন। আপনি **"Go to Definition"** ব্যবহার করে কোনো ভ্যারিয়েবল বা ফাংশনের ডিফিনিশনে যেতে পারবেন, অথবা **"Find References"** ব্যবহার করে দেখতে পারবেন, কোথায় কোথায় সেই ভ্যারিয়েবল বা ফাংশন ব্যবহৃত হচ্ছে।

### **এটি কেন গুরুত্বপূর্ণ?**
TypeScript কোড লেখার সময় আপনাকে অনেকগুলো সুবিধা দেয়:
- **বেশি উৎপাদনশীলতা (Higher productivity):** আপনি যখন কোড লেখেন, তখন TypeScript স্বয়ংক্রিয়ভাবে ভুল ধরিয়ে দেয়, এবং সঠিক ফাংশন বা প্রপার্টি সম্পর্কে পরামর্শ দেয়। এটি আপনাকে কোড লেখার সময় সময় বাঁচাতে সাহায্য করে।
- **কোডের গুণগত মান (Code quality):** TypeScript এর টাইপ সিস্টেম এবং টুলিং এর মাধ্যমে কোডের গুণগত মান বৃদ্ধি পায়, কারণ এটি ত্রুটি দ্রুত ধরা এবং ফিক্স করার সুযোগ দেয়।
- **ক্রস-প্ল্যাটফর্ম সাপোর্ট (Cross-platform support):** TypeScript সমর্থিত এডিটরগুলো প্রায় সব প্ল্যাটফর্মে (Windows, macOS, Linux) কাজ করে, তাই আপনি যেখানে চান সেখানে কোড লিখতে পারবেন।

### 
TypeScript এর **টুলিং ফিচার** কোড লেখা আরও সহজ, দ্রুত এবং নিরাপদ করে তোলে। এটি কোড সম্পাদনার সময় আপনাকে **ত্রুটি ধরতে**, **কোড রিফ্যাক্টর করতে**, এবং **ফাংশন ও ভ্যারিয়েবল এর ডেফিনিশন খুঁজে পেতে** সাহায্য করে। TypeScript সঠিকভাবে ব্যবহার করলে কোডিং অভিজ্ঞতা আরও উন্নত হবে এবং বাগ কম থাকবে।




------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### **`tsc` - TypeScript Compiler **

TypeScript একটি **স্ট্যাটিক টাইপিং** ভাষা, যেটি আমাদের কোডে টাইপ সম্পর্কিত ত্রুটি চিহ্নিত করতে সহায়তা করে। তবে, এই টাইপ চেকিং করার জন্য আমরা TypeScript কম্পাইলার **`tsc`** ব্যবহার করি, যেটি TypeScript কোডকে **JavaScript** কোডে রূপান্তরিত (compile) করে। চলুন, একে সহজভাবে ব্যাখ্যা করি।

### **১. TypeScript কম্পাইলার `tsc` কী?**

`tsc` (TypeScript Compiler) হলো TypeScript কোডকে **JavaScript** এ রূপান্তর করার সরঞ্জাম। যেহেতু ব্রাউজার ও Node.js **JavaScript** রান করে, TypeScript কোড প্রথমে কম্পাইল হতে হয় এবং তারপর JavaScript হিসেবে রান হয়।

### **২. `tsc` ইন্সটল করা**

প্রথমে `tsc` (TypeScript Compiler) ব্যবহার করার জন্য আমাদের **TypeScript** প্যাকেজটি ইনস্টল করতে হবে। এটি **npm** (Node Package Manager) ব্যবহার করে করা হয়। 

```bash
npm install -g typescript
```

এটি **TypeScript** কম্পাইলারটি **গ্লোবালি** (অথবা সার্বজনীনভাবে) ইনস্টল করবে। এখন আপনি যেকোনো ফোল্ডারে গিয়ে **TypeScript** কোড রান করতে পারবেন।

#### যদি আপনি কম্পাইলারটি **লোকালি** ইনস্টল করতে চান, তাহলে আপনি `npx` ব্যবহার করতে পারেন যা আপনার প্রকল্পের `node_modules` ফোল্ডার থেকে টুলটি চালায়।

### **৩. প্রথম TypeScript প্রোগ্রাম লেখা**

এখন, আমরা একটি **খালি ফোল্ডারে** গিয়ে আমাদের প্রথম TypeScript প্রোগ্রাম লিখব। ফাইলের নাম হবে `hello.ts`।

**hello.ts** ফাইলের কোড:

```typescript
// পৃথিবীকে স্বাগতম জানায়।
console.log("Hello world!");
```

এটি একটি **জাভাস্ক্রিপ্ট** প্রোগ্রামের মতোই, যেখানে `console.log` ব্যবহার করা হয়েছে "Hello world!" প্রিন্ট করার জন্য। TypeScript এখানে শুধু **টাইপ চেকিং** করবে।

### **৪. টাইপ চেকিং চালানো**

এখন, TypeScript কোডে **টাইপ চেকিং** চালানোর জন্য আমাদের `tsc` কমান্ডটি ব্যবহার করতে হবে:

```bash
tsc hello.ts
```

এটা চালানোর পর কিছু বিশেষ রেজাল্ট আসবে:

1. **কোনো ত্রুটি নেই:** যদি কোডে কোনো টাইপ চেকিংয়ের সমস্যা না থাকে, তাহলে **কোনো আউটপুট** থাকবে না।
2. **একটি `.js` ফাইল তৈরি হবে:** আপনি দেখতে পাবেন যে `hello.ts` এর পাশেই একটি নতুন `hello.js` ফাইল তৈরি হয়েছে।

এটি TypeScript এর **কম্পাইলিং** প্রক্রিয়া: TypeScript কোড `.ts` ফাইল থেকে `.js` ফাইলে রূপান্তরিত হবে। এখানে `hello.ts` এর কনটেন্ট এবং `hello.js` এর কনটেন্ট একদম একই থাকবে কারণ TypeScript কোনো টাইপিং ইস্যু খুঁজে পায়নি।

**hello.js** ফাইলের কনটেন্ট দেখতে পাবেন:

```javascript
// পৃথিবীকে স্বাগতম জানায়।
console.log("Hello world!");
```

### **৫. টাইপ চেকিং ত্রুটি (Error)**

ধরা যাক, আমরা কিছু ভুল টাইপিং বা ত্রুটি করেছি। উদাহরণস্বরূপ:

**hello.ts** ফাইলটি এমন লেখা হয়েছে:

```typescript
// একটি সাধারণ গ্রিটার ফাংশন:
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`);
}

greet("Brendan");
```

এখানে, `greet` ফাংশনে **২টি আর্গুমেন্ট** পাঠানোর কথা, কিন্তু আমরা **মাত্র ১টি আর্গুমেন্ট** পাঠিয়েছি (কেবল `"Brendan"`)। এই কারণে TypeScript ত্রুটি দেখাবে।

এখন `tsc hello.ts` চালানোর পর আপনি দেখতে পাবেন:

```bash
Expected 2 arguments, but got 1.
```

এটি TypeScript এর টাইপ চেকিং প্রক্রিয়া, যা আমাদের বলে দেয় যে **আমরা ভুল আর্গুমেন্ট পাস করেছি।**

### **৬. `tsc` এর কাজ এবং উপকারিতা**

TypeScript কম্পাইলার **`tsc`** কেবল কোডটি JavaScript এ রূপান্তরিতই করে না, তা সঠিকভাবে টাইপ চেকিং করেও দেয়। এর মাধ্যমে আমরা সহজেই:

- **টাইপ সম্পর্কিত ভুল ধরতে পারি**। যেমন, ভুলভাবে আর্গুমেন্ট সংখ্যা পাস করা বা টাইপ মেলানো।
- **এনট্রিপ্রাইজ কোডের মান উন্নত করতে পারি**। TypeScript নিশ্চিত করে যে কোডটি টাইপ সেফ (Type-safe) হবে।
  
### 

TypeScript কম্পাইলার **`tsc`** হল TypeScript কোডকে JavaScript কোডে রূপান্তর করার সরঞ্জাম। এটি **টাইপ চেকিং** করে আমাদের ভুলগুলো চিহ্নিত করে, এবং সঠিক কোড লেখার জন্য সহায়তা করে। 

- প্রথমে `tsc` ইনস্টল করতে হবে।
- তারপর আপনার TypeScript কোডে `tsc` কমান্ড চালিয়ে টাইপ চেকিং এবং কম্পাইলিং করা হবে।
- TypeScript আপনাকে **ত্রুটি** জানাবে, যদি কোনো টাইপিং ভুল থাকে, এবং JavaScript আউটপুট দিবে।

এইভাবে, `tsc` ব্যবহার করে আপনি **TypeScript** এর শক্তি সম্পূর্ণভাবে ব্যবহার করতে পারেন এবং কোডের গুণগত মান বৃদ্ধি করতে পারেন।

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
### **Emitting with Errors: TypeScript এ ত্রুটি সহ কোড রূপান্তর**

TypeScript কোড কম্পাইল করার সময়, কখনও কখনও **ত্রুটি** হতে পারে। কিন্তু প্রশ্ন হলো, ত্রুটি থাকা সত্ত্বেও TypeScript কি **JavaScript** ফাইল তৈরি করবে? এটি সম্পর্কে বিস্তারিত জানবো।

### **১. `hello.js` ফাইলের পরিবর্তন**

আমাদের প্রথম উদাহরণে, যখন আমরা `tsc hello.ts` চালালাম, তখন **`hello.js`** ফাইলটি তৈরি হয়েছিল। কিন্তু কিছু ত্রুটি (যেমন, ভুল আর্গুমেন্ট পাস করা) সত্ত্বেও `hello.js` ফাইলটি তৈরি হয়েছিল এবং এর কনটেন্টও আগের মতোই ছিল। এটি একটু অস্বাভাবিক মনে হতে পারে, কারণ TypeScript ত্রুটি দেখিয়েছে, কিন্তু এটি TypeScript এর একটি **মূল ধারণা**।

### **২. TypeScript এর মূল ধারণা**

TypeScript এ **টাইপ চেকিং** করে কোডের ত্রুটি চিহ্নিত করা হয়, কিন্তু TypeScript এর একটি মূল ধারণা হলো **কোড চালানোর সময় আপনিই ভালো জানবেন, TypeScript না**। অর্থাৎ, কখনও কখনও TypeScript ভুল ধরতে পারে, কিন্তু আপনার কোডের কার্যকারিতা ঠিক থাকতে পারে। TypeScript সঠিকভাবে কোডটিকে চালাতে বাধা দেয় না।

### **৩. কোড চালানো বন্ধ করার প্রশ্ন**

ধরা যাক, আপনি JavaScript কোড থেকে TypeScript এ পরিবর্তন করছেন এবং তাতে কিছু টাইপ চেকিং ত্রুটি ঘটেছে। তবে আপনার পূর্ববর্তী JavaScript কোডটি ঠিকঠাক কাজ করছিল। এখন, TypeScript এ কোডটি রূপান্তরিত করার সময় যদি ত্রুটি আসে, তাহলে কোডটি চালানো বন্ধ করে দেয়ার কোনো কারণ নেই, কারণ আগের কোডটি ঠিকই কাজ করছিল।

### **৪. `noEmitOnError` অপশন**

TypeScript ত্রুটি থাকলে কোড রূপান্তরিত না করতে চাইলে, আপনি **`noEmitOnError`** কম্পাইলার অপশন ব্যবহার করতে পারেন। এই অপশনটি ব্যবহার করলে **যতটুকু ত্রুটি থাকবে, ততটুকু কোড রূপান্তরিত হবে না**।

#### উদাহরণ:
আপনার `hello.ts` ফাইলটি যদি ত্রুটি থাকে, তাহলে **`tsc --noEmitOnError`** ব্যবহার করে কম্পাইল করলে নতুন **`hello.js`** ফাইল তৈরি হবে না।

```bash
tsc --noEmitOnError hello.ts
```

এই কমান্ডটি চালানোর পর আপনি দেখতে পাবেন যে **`hello.js`** ফাইলটি আপডেট হয়নি। কারণ TypeScript দেখেছে যে কোডে ত্রুটি আছে এবং সেই ত্রুটির কারণে এটি JavaScript ফাইল তৈরি করতে দেয়নি।

### **৫. কেন এটি গুরুত্বপূর্ণ?**

এটি গুরুত্বপূর্ণ কারণ, কখনও কখনও আমরা কোডের উন্নতি বা রিফ্যাক্টরিং (refactoring) করতে চাই, কিন্তু যদি TypeScript এক্সিকিউটেবল কোডের মধ্যে কোনো ত্রুটি দেখায়, তাহলে সেই কোড চলবে না। **`noEmitOnError`** অপশনটি ব্যবহার করে আপনি TypeScript কে বলছেন যে "যতক্ষণ না ত্রুটি ঠিক হচ্ছে, ততক্ষণ পর্যন্ত নতুন কোড তৈরি করো না।"

### 

TypeScript কম্পাইল করার সময় ত্রুটি থাকা সত্ত্বেও কোড **JavaScript** এ রূপান্তরিত হতে পারে, কারণ TypeScript মাঝে মাঝে বুঝতে পারে যে আপনি হয়তো এমন কিছু করেই ফেলেছেন যেটি বাস্তবে সঠিক, কিন্তু টাইপ সিস্টেমের জন্য ত্রুটি তৈরি হয়েছে। তবে, আপনি যদি চান যে ত্রুটি থাকলে কোড রূপান্তরিত না হয়, তাহলে **`--noEmitOnError`** অপশন ব্যবহার করে TypeScript কে নির্দেশ দিতে পারেন।

এইভাবে, **TypeScript** আপনাকে আরও নির্ভরযোগ্য এবং নিরাপদ কোড লেখার সুযোগ দেয়, যেখানে ত্রুটি গুলি চিহ্নিত করা হয়, কিন্তু আপনি যখন চান তখন তা চালানোও হতে পারে।


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
### **Explicit Types in TypeScript **

TypeScript আমাদের কোডে **টাইপ সেফটি** (Type Safety) দিতে সাহায্য করে। এর মাধ্যমে আমরা কোডের ভেতরে **টাইপ** স্পষ্টভাবে উল্লেখ করতে পারি, যার ফলে আমাদের কোডের ত্রুটিগুলি সহজে ধরা পড়ে। চলুন, একে সহজ ভাষায় এবং বিস্তারিতভাবে বুঝে নিই।

### **১. টাইপ স্পষ্ট করা (Explicit Types)**

আজ পর্যন্ত, আমরা `greet` ফাংশনে **`person`** এবং **`date`** এর টাইপ উল্লেখ করিনি। এর মানে, TypeScript এগুলোর টাইপ বুঝতে পারছে না। কিন্তু আমরা চাইলে আমরা **এগুলোর টাইপ স্পষ্ট করে (explicitly define)** TypeScript কে জানাতে পারি। ধরুন, `person` এর টাইপ **string** এবং `date` এর টাইপ **Date** হতে হবে।

### **২. টাইপ এনোটেশন (Type Annotations) ব্যবহার করা**

আমরা **টাইপ এনোটেশন** ব্যবহার করে TypeScript কে বলেছি যে:

- **`person`** একটি `string` টাইপ।
- **`date`** একটি `Date` টাইপ হবে।

এখন কোডটি এমনভাবে দেখতে হবে:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

এটি যে কাজটি করছে তা হলো: **`greet` ফাংশন** এখন **`person`** (একটি string) এবং **`date`** (একটি Date অবজেক্ট) আর্গুমেন্ট হিসেবে নেবে।

### **৩. TypeScript এর সাহায্যে ভুল ধরানো**

এখন, TypeScript আমাদের অন্য কিছু ভুলও ধরিয়ে দিতে পারবে, যদি আমরা ভুল টাইপ দিয়ে ফাংশন কল করি। উদাহরণস্বরূপ:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", Date());
```

এখানে দ্বিতীয় আর্গুমেন্ট **`Date()`** দেওয়া হয়েছে। কিন্তু `Date()` ফাংশনটি কি দেয়? এটা আসলে একটি **স্ট্রিং** রিটার্ন করে, যা **`Date` অবজেক্ট** নয়। এর ফলে, TypeScript ত্রুটি দেখাবে:



### **৪. সমাধান: সঠিক টাইপ ব্যবহার করা**

এখন, আমাদের এই ভুলটি ঠিক করার জন্য **`new Date()`** ব্যবহার করতে হবে, যা একটি **`Date` অবজেক্ট** রিটার্ন করে:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", new Date());
```

এখন, কোডটি সঠিকভাবে কাজ করবে, কারণ `new Date()` একটি সঠিক **Date অবজেক্ট** রিটার্ন করছে, যা TypeScript এর টাইপ চেকিংয়ের সাথে মেলে।

### **৫. টাইপ এনোটেশন ছাড়াও TypeScript এর কাজ**

তবে, TypeScript সব সময় **explicit টাইপ এনোটেশন** প্রয়োজন হয় না। **TypeScript অনেক ক্ষেত্রেই অটোমেটিক্যালি টাইপ ইন্সফার (infer)** করে, অর্থাৎ TypeScript নিজেই বুঝতে পারে কোন ভ্যারিয়েবল কী টাইপ হতে পারে।

**যেমন:**

```typescript
let msg = "hello there!";
```

এখানে, আমরা টাইপ উল্লেখ না করলেও TypeScript বুঝে নেবে যে **`msg`** একটি `string` টাইপ ভ্যারিয়েবল। TypeScript অটোমেটিক্যালি এটি সঠিক টাইপ হিসেবে ইন্সফার (infer) করে নেবে।

### **৬. টাইপ এনোটেশন ব্যবহার না করা**

যেহেতু TypeScript সহজেই টাইপ ইন্সফার করতে পারে, তাই অনেক সময় **টাইপ এনোটেশন ব্যবহার না করাই ভাল**, যদি TypeScript সঠিক টাইপ খুঁজে পায়। এটা কোডকে সহজ এবং পরিস্কার রাখে।

**উদাহরণ:**

```typescript
let msg = "hello there!";  // TypeScript সঠিকভাবে বুঝবে যে এটি একটি string টাইপ
```

এখানে আমরা টাইপ স্পষ্টভাবে উল্লেখ করি নি, কিন্তু TypeScript জানে যে `msg` একটি স্ট্রিং। TypeScript নিজেই এটি সঠিকভাবে টাইপ করেছে, ফলে টাইপ এনোটেশন যোগ করার দরকার নেই।

### 

- **Explicit Types (টাইপ এনোটেশন)** ব্যবহার করে আপনি TypeScript কে স্পষ্টভাবে জানাতে পারেন কোন ভ্যারিয়েবল কী টাইপ হবে।
- টাইপ স্পষ্টভাবে উল্লেখ করলে TypeScript আপনার কোডের ত্রুটি ধরা সহজ করে, যেমন ভুল টাইপ পাস করা।
- যদিও **explicit types** দরকার হতে পারে, TypeScript অনেক সময় **টাইপ ইন্সফার** (auto type inference) করতে পারে, অর্থাৎ কোড দেখে টাইপ অনুমান করতে পারে।
- যখন TypeScript নিজে টাইপ ইন্সফার করে, তখন অতিরিক্ত টাইপ এনোটেশন ব্যবহার করা প্রয়োজন নয়।

এভাবে TypeScript আপনাকে **টাইপ সেফটি** নিশ্চিত করতে সাহায্য করে, এবং যখন দরকার হয় তখন explicit types ব্যবহার করে আপনার কোডকে আরও সঠিক এবং বাগ মুক্ত রাখে।

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
### **Erased Types in TypeScript**

TypeScript এর অন্যতম বৈশিষ্ট্য হলো **টাইপ সিস্টেম**, যা আমাদের কোডে ভুল ধরতে সাহায্য করে। কিন্তু একবার যখন TypeScript কোডটি **JavaScript** এ রূপান্তরিত হয়, তখন টাইপ ইনফরমেশন **মুছে যায়** বা **ধ্বংস** হয়ে যায়। আসুন, এটি কীভাবে কাজ করে এবং এর গুরুত্ব কী, তা বিশ্লেষণ করি।

### **১. টাইপ অ্যানোটেশন মুছে যাওয়া**

ধরা যাক, আমাদের একটি **TypeScript ফাংশন** আছে যেটি টাইপ অ্যানোটেশন দিয়ে লিখা:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", new Date());
```

এখানে, **`person`** এর টাইপ **`string`** এবং **`date`** এর টাইপ **`Date`** স্পষ্টভাবে উল্লেখ করা হয়েছে।

### **২. TypeScript কোড JavaScript এ রূপান্তর**

এখন, আমরা যখন এই কোডটি **TypeScript কম্পাইলার (tsc)** দিয়ে কম্পাইল করি, তখন **JavaScript ফাইল** উৎপন্ন হবে। এই JavaScript ফাইলটি এমন কিছু দেখাবে:

```javascript
"use strict";
function greet(person, date) {
    console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
}
greet("Maddison", new Date());
```

এখানে আমরা দেখতে পাচ্ছি যে:

1. **`person`** এবং **`date`** প্যারামিটারগুলোর টাইপ অ্যানোটেশন (যেমন `string`, `Date`) **মুছে** গিয়েছে। JavaScript এ টাইপ অ্যানোটেশন নেই, তাই TypeScript নিজেই তা সরিয়ে দিয়েছে।
   
2. **`template string`** যেটি backticks (\`\`) দিয়ে তৈরি হয়েছিল, তা JavaScript এ **plain string concatenation** এ রূপান্তরিত হয়েছে। উদাহরণস্বরূপ, `${person}` এবং `${date.toDateString()}` অংশগুলি JavaScript এ কনক্যাটেনেশন হিসেবে পরিণত হয়েছে।

### **৩. টাইপ অ্যানোটেশন এবং রানটাইমের সম্পর্ক**

এটি মনে রাখা জরুরি যে **টাইপ অ্যানোটেশন** গুলি JavaScript ফাইলে **অতिरिक्त কিছু নয়**। **টাইপ অ্যানোটেশনগুলো কেবল টাইপ চেকিংয়ের জন্য** ব্যবহৃত হয়, যা **কেবল কম্পাইলিং** সময় কার্যকর। কম্পাইল হওয়ার পরে, এই টাইপ সিস্টেমের কোনো প্রভাব **রানটাইম** এ থাকে না। অর্থাৎ:

- **Type annotations** কখনও রানটাইমে আপনার কোডের আচরণ পরিবর্তন করে না।
- যখন TypeScript কোডটি **JavaScript** এ রূপান্তরিত হয়, তখন টাইপ সংক্রান্ত সমস্ত ইনফরমেশন **মুছে** যায়। এতে কোডের কার্যকারিতা একেবারে একই থাকে।

### **৪. TypeScript এর প্রয়োজন কেন?**

TypeScript এর প্রধান কাজ হচ্ছে **টাইপ চেকিং**। যদিও JavaScript এ টাইপ অ্যানোটেশন থাকতে পারে না, TypeScript **কম্পাইলার** আমাদের টাইপ-ভিত্তিক ত্রুটিগুলি **ধরা** এবং **সংশোধন** করতে সাহায্য করে। কম্পাইল হওয়া JavaScript কোডে টাইপ অ্যানোটেশন মুছে যাওয়ার পরও, **JavaScript রানটাইম** ঠিকভাবে চলে।

### **৫. টাইপ অ্যানোটেশন কখন মুছে যায়?**

TypeScript এর টাইপ অ্যানোটেশন শুধুমাত্র **কম্পাইলিং সময়** থাকে। আপনি যখন TypeScript কোডটি কম্পাইল করেন, তখন:

- টাইপ অ্যানোটেশন (যেমন `person: string`) **JavaScript** ফাইলে থাকে না।
- TypeScript কোডের **কোনো বৈশিষ্ট্য** রানটাইমে কাজ করবে না, যদি তা শুধুমাত্র টাইপ সম্পর্কিত হয়।

অর্থাৎ, TypeScript কেবল আমাদের **বাগ ধরা** এবং **কোডের স্থিতিশীলতা** নিশ্চিত করার জন্য ব্যবহৃত হয়, কিন্তু শেষমেশ JavaScript কোডের মধ্যে এই টাইপ ইনফরমেশন **কোনো প্রভাব ফেলে না**।



- **TypeScript** ব্যবহার করে আপনি টাইপ অ্যানোটেশন এবং টাইপ চেকিং করতে পারেন, কিন্তু যখন TypeScript কোড JavaScript এ রূপান্তরিত হয়, টাইপ সম্পর্কিত সবকিছু **মুছে** যায়।
- **টাইপ অ্যানোটেশন** কখনো **JavaScript রানটাইমে** কোনো প্রভাব ফেলে না।
- TypeScript এর উদ্দেশ্য হলো **কেবল টাইপ চেকিং** করা, এবং একবার কোড কম্পাইল হওয়ার পর, টাইপ সংক্রান্ত ইনফরমেশন আর থাকে না।
- TypeScript এর এই **টাইপ অ্যানোটেশন** রানটাইমের আচরণ পরিবর্তন করে না, এটি শুধুমাত্র উন্নত ডেভেলপমেন্ট অভিজ্ঞতা দেয়।

এইভাবে, TypeScript এবং JavaScript এর মধ্যে **টাইপ অ্যানোটেশন** এর পার্থক্য এবং **টাইপ চেকিং** এর ভূমিকা পরিষ্কার হয়।


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```javascript
function greeting(person, date) {
    console.log(`Hello ${person}, today is ${date.toDateString()}`);
}

console.log(greeting("anim", new Date()));
```

### **এটি কী করে?**
1. **`greeting` ফাংশনটি**: 
    - এটি একটি ফাংশন যা দুটি প্যারামিটার নেয়: `person` (যা একটি নাম হবে) এবং `date` (যা একটি তারিখ হবে)। 
    - এই ফাংশনটি **`console.log()`** ব্যবহার করে একটি স্ট্রিং প্রিন্ট করে, যেখানে `person` এবং `date` ব্যবহৃত হয়।
    - `date.toDateString()` মেথডটি `Date` অবজেক্টের `date` প্যারামিটার থেকে তারিখের একটি মানবিক ফরম্যাটে স্ট্রিং রিটার্ন করবে।

2. **`greeting("anim", new Date())`**:
    - এখানে, **"anim"** এবং **`new Date()`** প্যারামিটার হিসেবে পাঠানো হচ্ছে।
    - **`new Date()`** বর্তমান তারিখ এবং সময়ের একটি `Date` অবজেক্ট তৈরি করবে।

3. **`console.log(greeting("anim", new Date()))`**:
    - `greeting` ফাংশনটি **`console.log()`** এর ভিতরে কল করা হয়েছে, অর্থাৎ এটি যা প্রিন্ট করবে তা `console.log()` এর মাধ্যমে আউটপুট হবে।
    - কিন্তু, ফাংশনটির মধ্যে **`console.log()`** আছে, যা **স্ট্রিং** আউটপুট করবে। তাই ফাংশনটি **`undefined`** ফেরত দেবে কারণ কোন `return` স্টেটমেন্ট নেই।

### **ফলাফল:**
আপনার কোডটি এই আউটপুট তৈরি করবে:

```
Hello anim, today is Mon Jan 08 2025!
undefined
```

- প্রথম লাইনটি হবে: `"Hello anim, today is Mon Jan 08 2025!"` (এই তারিখটি বর্তমান তারিখের উপর ভিত্তি করে পরিবর্তিত হবে)।
- দ্বিতীয় লাইনটি `"undefined"` হবে, কারণ `greeting()` ফাংশনটি কিছু **`return`** করেনি, তাই এটি **`undefined`** ফেরত দেয়।

### **সমস্যা এবং উন্নতি:**

যেহেতু আপনি **`console.log()`** ফাংশনের ভিতরে `greeting` ফাংশনটি কল করেছেন, এটি **ফাংশনের রিটার্ন ভ্যালু** (যা `undefined`) আউটপুট হিসাবে দেখায়। আপনি যদি ফাংশনটি ব্যবহার করার পরে কোনও মান ফেরত দিতে চান, তাহলে আপনাকে একটি **`return`** স্টেটমেন্ট যোগ করতে হবে।

### **আপডেট করা কোড:**

```javascript
function greeting(person, date) {
    return `Hello ${person}, today is ${date.toDateString()}`;
}

console.log(greeting("anim", new Date()));
```

এখন, এই কোডটি সঠিকভাবে কাজ করবে এবং আউটপুট হবে:

```
Hello anim, today is Mon Jan 08 2025!
```

এখানে:

- **`greeting()`** ফাংশনটি একটি স্ট্রিং রিটার্ন করছে এবং এটি সরাসরি **`console.log()`** এ প্রদর্শিত হচ্ছে।


- TypeScript এর টাইপ অ্যানোটেশন গুলি **JavaScript এ রূপান্তরিত** হওয়ার পর মুছে যায়।
- JavaScript কোডের মধ্যে **টাইপ অ্যানোটেশন** বা টাইপ চেকিং থাকে না।
- TypeScript টাইপ চেকিং ব্যবহারের মাধ্যমে আপনি ভুল দ্রুত শনাক্ত করতে পারেন, তবে JavaScript রানটাইমে কোন টাইপ চেকিং করা হয় না।

**TypeScript এর মূল লক্ষ্য** হলো আপনার কোডে টাইপ সিস্টেমের সাহায্যে **বাগ হানা** এবং **উন্নত ডেভেলপমেন্ট অভিজ্ঞতা** প্রদান করা, কিন্তু রানটাইমে JavaScript কোডটি ঠিকমত কাজ করবে।


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
### **Downleveling**

**Downleveling** একটি প্রক্রিয়া যেখানে TypeScript একটি নতুন সংস্করণের কোডকে পুরনো সংস্করণে রূপান্তরিত করে, যাতে এটি পুরানো ব্রাউজারে বা JavaScript রানটাইমে কাজ করতে পারে। এই প্রক্রিয়াকে সাধারণত **"downleveling"** বলা হয়। চলুন, এই বিষয়টি সহজ ভাষায় বিশ্লেষণ করি।


আপনার কোডে যে **template string** ব্যবহার করা হয়েছে, সেটা ছিল:

```typescript
`Hello ${person}, today is ${date.toDateString()}!`;
```

এটি **ECMAScript 2015 (ES6)** এর একটি ফিচার। তবে, TypeScript এর ডিফল্ট সেটিং হলো কোডকে পুরনো **ECMAScript 5 (ES5)** ভার্সনে রূপান্তর করা। এবং তাই, TypeScript এটি রূপান্তর করে পুরনো স্টাইলের কোডে, যেমন:

```javascript
"Hello ".concat(person, ", today is ").concat(date.toDateString(), "!");
```

এটি কেন হলো? কারণ:

### **ECMAScript 2015 (ES6) ও ES5-এর পার্থক্য:**
- **Template strings** (যেমন `` `Hello ${person}` ``) ES6-এ যুক্ত হয়েছিল।
- ES5-এ এই ধরনের ফিচার ছিল না। তাই TypeScript **downleveling** ব্যবহার করে **`.concat()`** মেথডের মাধ্যমে কোডকে পুরনো স্টাইলে রূপান্তরিত করে।

### **Downleveling কী?**
Downleveling হল এমন একটি প্রক্রিয়া যেখানে নতুন ECMAScript এর ফিচারগুলোকে পুরনো সংস্করণে রূপান্তর করা হয়, যাতে সেগুলো পুরনো ব্রাউজার বা রানটাইম পরিবেশে চলতে পারে।

### **ট্রান্সপাইলিং (Transpiling):**
TypeScript **transpiler** (যা কোডকে এক ভাষা থেকে অন্য ভাষায় রূপান্তর করে) এমনভাবে কাজ করে যে, এটি ES6 বা তার পরবর্তী সংস্করণের ফিচারগুলোকে পুরনো **ES5** এর স্টাইলে রূপান্তর করে দেয়।

#### **উদাহরণ:**
আপনি যদি নিচের কোডটি লিখেন:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

এটি **ES6** এর **template string** ব্যবহার করছে। যখন আপনি এটি TypeScript-এ কম্পাইল করেন, TypeScript পুরনো **ES5** কম্প্যাটিবল কোডে রূপান্তর করবে। এর ফলস্বরূপ কোডটি কিছু এমন হয়ে যাবে:

```javascript
function greet(person, date) {
  console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
}
```

### **TypeScript Target Option:**
TypeScript এর একটি খুব শক্তিশালী ফিচার হল আপনি চাইলে এটি কোন ECMAScript ভার্সনকে লক্ষ্য করে কোড কম্পাইল করবে তা নির্ধারণ করতে পারেন। **`--target`** অপশনটি ব্যবহার করে আপনি TypeScript কে নির্দিষ্ট ECMAScript ভার্সন ব্যবহার করতে বল सकते।

- **ডিফল্ট টার্গেট** হলো **ES5** (যা খুব পুরনো)। 
- আপনি যদি ES6 বা তার পরবর্তী ভার্সনে কোড চালাতে চান, তবে **`--target es2015`** ব্যবহার করতে পারেন।

#### **কিভাবে কাজ করবে?**
যদি আপনি `tsc --target es2015 hello.ts` কমান্ড চালান, তবে TypeScript ES6 কোড রূপান্তর করবে, যেমন:

```javascript
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
greet("Maddison", new Date());
```

এখন, কোডটি **ES6** এর ফিচার ব্যবহার করছে এবং এটি **ES2015**-এর সমর্থনকারী যেকোনো ব্রাউজারে চালানো যাবে।

### **এটি কেন গুরুত্বপূর্ণ?**
1. **পুরনো ব্রাউজারের সাথে সামঞ্জস্য**: যদি আপনি একটি অ্যাপ্লিকেশন তৈরি করছেন এবং নিশ্চিত না হন যে ব্যবহারকারী পুরানো ব্রাউজার ব্যবহার করছেন কিনা, তবে TypeScript-কে ES5 এ কম্পাইল করা উপকারী হতে পারে। এটি পুরনো ব্রাউজারে কোডটি চালানোর জন্য উপযুক্ত করে তোলে।
   
2. **নতুন ব্রাউজারের সুবিধা**: তবে বর্তমানে অধিকাংশ ব্রাউজার **ES2015** এবং তার পরবর্তী সংস্করণ সমর্থন করে। তাই যদি আপনার অ্যাপ্লিকেশনটি আধুনিক ব্রাউজারে চলে, তাহলে আপনি **ES2015** বা তার পরবর্তী সংস্করণে কোড কম্পাইল করতে পারেন।


TypeScript **downleveling** বা **transpiling** ব্যবহার করে নতুন ECMAScript ফিচারগুলোকে পুরনো সংস্করণে রূপান্তর করতে সক্ষম, যা পুরনো ব্রাউজারগুলির সাথে সামঞ্জস্যপূর্ণ। আপনি যখন TypeScript ব্যবহার করেন, তখন এটি আপনার কোডকে এমনভাবে কম্পাইল করবে যাতে আপনি নির্দিষ্ট ECMAScript সংস্করণে কোড চালাতে পারেন। `--target` অপশনটি ব্যবহার করে আপনি এটি কাস্টমাইজও করতে পারেন। 

এটি একটি শক্তিশালী ফিচার, যা আপনার কোডের ব্রাউজার সামঞ্জস্যতা এবং রক্ষণাবেক্ষণ আরও সহজ করে তোলে।



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
আপনার TypeScript কোড যদি  ES6-এ কম্পাইল হয়  তার পেছনে কয়েকটি কারণ থাকতে পারে। চলুন, আমরা বিষয়টি বিস্তারিতভাবে বুঝে দেখি।

### 1. **TypeScript Target Option**
TypeScript ডিফল্টভাবে **ES5** তে কোড কম্পাইল করে, তবে আপনি যদি `--target` অপশন ব্যবহার করেন, তবে TypeScript কোডটি সেই নির্দিষ্ট ECMAScript সংস্করণে কম্পাইল করবে।

যদি আপনি TypeScript কম্পাইল করার সময় `--target es2015` বা এর পরবর্তী কোনো ভার্সন ব্যবহার করেন, তাহলে TypeScript কোডটি ES6 (ECMAScript 2015) বা তার পরবর্তী সংস্করণে রূপান্তরিত হবে।

#### **কিভাবে পরীক্ষা করবেন?**

আপনি যদি নিশ্চিত না হন যে আপনার কোড কোন ভার্সনে কম্পাইল হচ্ছে, তাহলে নিচের পদক্ষেপগুলো অনুসরণ করুন:

1. **tsconfig.json ফাইল চেক করুন**:
   - যদি আপনার প্রজেক্টে `tsconfig.json` ফাইল থাকে, তবে সেই ফাইলটি খুলে চেক করুন। সেখানে `"target"` অপশনটি যদি `es2015` বা তার পরবর্তী কোনো সংস্করণে সেট করা থাকে, তাহলে TypeScript কোডটি সেই সংস্করণে কম্পাইল হবে।
   
   উদাহরণ:
   ```json
   {
     "compilerOptions": {
       "target": "es2015"
     }
   }
   ```

   এর মানে হলো TypeScript কোডটি **ES6** এ কম্পাইল হবে।

2. **কমান্ড লাইন থেকে `--target` চেক করুন**:
   যদি আপনি কম্পাইলেশন করার সময় `tsc` কমান্ডে `--target` অপশন ব্যবহার করেন, তাহলে সেই অপশন অনুযায়ী কোড কম্পাইল হবে। উদাহরণ:

   ```bash
   tsc --target es2015 hello.ts
   ```

   এই কমান্ডটি TypeScript কোডকে **ES6** তে কম্পাইল করবে।

### 2. **ES6 ফিচারগুলোর ব্যবহার**
TypeScript যখন ES6 তে কোড কম্পাইল করে, তখন **template literals**, **arrow functions**, **let/const**, **classes** এবং অন্যান্য ES6 ফিচারগুলো  থাকবে। যদি আপনি এমন কোনো ফিচার ব্যবহার করেন যা ES6 এর অংশ, তবে TypeScript সেই ফিচারগুলো **ES6**-এর কোড হিসেবে কম্পাইল করবে।

উদাহরণস্বরূপ, আপনার কোডে যদি **template strings** বা **arrow functions** থাকে, তবে সেগুলো ES6 এর কোডে থাকবে:

```typescript
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

কম্পাইল হওয়ার পর:

```javascript
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

এটি ES6 কোড, এবং আপনি যদি **ES5** টার্গেট করেন, তাহলে TypeScript কোডটি **concat()** দিয়ে পরিবর্তন করবে।

### 3. **TypeScript কম্পাইলার `tsc` এবং `tsconfig.json`**
এছাড়াও, TypeScript কম্পাইলার `tsc` যদি **`tsconfig.json`** ফাইলের ভিতরে দেওয়া সেটিংস অনুযায়ী কম্পাইল করে, তাহলে আপনি যেকোনো সময় সেই ফাইলের মধ্যে **`"target"`** অপশন পরিবর্তন করতে পারেন। 

যদি আপনার **`tsconfig.json`** ফাইলে `"target": "es6"` লেখা থাকে, তবে TypeScript সেই সেটিংস অনুসরণ করবে এবং কোড ES6 তে কম্পাইল হবে।

### 4. **TypeScript কোডের রানটাইম নির্ভরতা**
TypeScript যখন কোড কম্পাইল করে, তখন তা ব্রাউজারের রানটাইম পরিবেশের সাথে সামঞ্জস্যপূর্ণ করতে চেষ্টা করে। যদি আপনার কোড ES6 ফিচারগুলো ব্যবহার করে (যেমন, `let`, `const`, `template literals` ইত্যাদি), এবং আপনি সেই কম্পাইলার অপশনে **ES6** টার্গেট করেন, তাহলে কোডটি ES6 ভার্সনে থাকবে।

### 5. **ES6 ব্রাউজার সাপোর্ট**
বর্তমানে অধিকাংশ আধুনিক ব্রাউজার **ES6** সমর্থন করে। তাই, আপনি যদি কম্পাইলেশন টাইমে ES6 টার্গেট করেন, তবে কোডটি এই ব্রাউজারগুলিতে সমস্যা ছাড়াই চলে যাবে। তবে, পুরনো ব্রাউজারে যদি কম্প্যাটিবিলিটি প্রয়োজন হয়, তাহলে আপনাকে **ES5** টার্গেট করতে হবে।

### **সমাধান:**
আপনার TypeScript কোড যদি ES6-এ কম্পাইল হয়ে থাকে এবং আপনি চাইছেন যে এটি **ES5** তে কম্পাইল হোক, তবে `tsconfig.json` বা কম্পাইলার অপশনে `"target": "es5"` সেট করতে পারেন।

**`tsconfig.json` উদাহরণ:**
```json
{
  "compilerOptions": {
    "target": "es5"
  }
}
```

এতে TypeScript কোডটি **ES5** তে কম্পাইল হবে।


- TypeScript কোডের **target** নির্ধারণ করতে **`--target`** অপশন বা **`tsconfig.json`** ফাইল ব্যবহার করা হয়।
- যদি **ES6** ফিচার ব্যবহার করেন এবং **ES6** এ কম্পাইল করতে চান, তবে `"target": "es6"` বা **`tsc --target es2015`** ব্যবহার করুন।
- **ES5** এ কোড কম্পাইল করতে চাইলে `"target": "es5"` ব্যবহার করুন।



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**Strictness in TypeScript**

### 1. **TypeScript এর Strictness: কেন এটি গুরুত্বপূর্ণ?**

TypeScript একটি স্ট্যাটিক টাইপ-চেকিং ভাষা, যার মানে হলো, কোডের টাইপগুলি কম্পাইল করার সময় চেক করা হয়। তবে TypeScript বিভিন্ন ব্যবহারকারীর প্রয়োজন অনুযায়ী *strictness* (কঠোরতা) কাস্টমাইজ করতে দেয়। কিছু ব্যবহারকারী চান TypeScript তাদের কোডের শুধুমাত্র কিছু অংশ চেক করুক, এবং কিছু ব্যবহারকারী চান যে TypeScript আরও কঠোরভাবে কোডটি চেক করুক। 

যদি আপনি TypeScript ব্যবহার করতে চান এবং শুধু কিছু জায়গায় টাইপ চেকিং করতে চান, তবে TypeScript এ আপনাকে কিছু অপশন দেওয়া হয়, যাতে আপনি কোডের নির্দিষ্ট অংশে টাইপ চেকিং চালু বা বন্ধ করতে পারেন।

### 2. **Loose Option:**

TypeScript ডিফল্টভাবে কিছু শিথিল অপশনে কাজ করে, যেখানে টাইপগুলি **অপশনাল** থাকে এবং **ইনফারেন্স** (type inference) সিস্টেমটি সবচেয়ে সহজ এবং নমনীয় টাইপ নির্বাচন করে। এর মানে হল:

- টাইপ অ্যানোটেশন দেওয়া না থাকলেও TypeScript স্বয়ংক্রিয়ভাবে টাইপ নির্ধারণ করতে চেষ্টা করে।
- **null/undefined** এর জন্য কোনো কঠোর চেকিং নেই। (মানে, কোনো ভেরিয়েবল **null** বা **undefined** হলে তা TypeScript ধরে না, এবং প্রোগ্রামটি চালু থাকতে পারে)
  
এটি পুরানো **JavaScript** কোড থেকে **TypeScript** এ মাইগ্রেট করার জন্য বেশ ভালো হতে পারে, কারণ আপনি কোডে কোনও বড় পরিবর্তন না করেই কমপাইল করাতে পারেন। তবে, যদি আপনি আরও কঠোর চেকিং চান, TypeScript আপনাকে সেটি করতে দেয়।

### 3. **Strict Mode:**

কিছু ব্যবহারকারী TypeScript থেকে আরো বিস্তারিত এবং কঠোর চেকিং চান। এই ধরনের ব্যবহারকারীরা **Strict Mode** ব্যবহার করেন। Strict Mode-এ TypeScript যতটা সম্ভব কোড চেক করে, এবং **বিভিন্ন ভুল** যেমন ভুল টাইপ, **null/undefined** ইস্যু ইত্যাদি ধরতে পারে।

TypeScript এ **Strict Mode** চালু করার মাধ্যমে, কোডের জন্য **কঠোর চেকিং** চালু হয়ে যায়, যা কোডের গুণমান এবং কার্যকারিতা উন্নত করে। এটি একটি গুরুত্বপূর্ণ বৈশিষ্ট্য, কারণ এটি ভবিষ্যতের বাগ এবং কোডের ভুলগুলি দ্রুত চিহ্নিত করতে সহায়তা করে।

### 4. **Strict Mode এর সুবিধা:**

- **কঠোর টাইপ চেকিং:** TypeScript কোডের টাইপ সঠিক কিনা তা চেক করে, এর ফলে টাইপ ভুলের সম্ভাবনা কমে যায়।
- **null এবং undefined চেকিং:** TypeScript কোডে যেখানে **null** বা **undefined** আসতে পারে, সেখানে TypeScript আপনাকে সাবধান করে দেয় এবং সেই বিষয়ে সঠিক সিদ্ধান্ত নিতে সাহায্য করে।
- **অভ্যন্তরীণ ভুল ধরার সুবিধা:** Strict Mode আপনাকে এমন ভুল গুলি ধরতে সাহায্য করে যেগুলি আপনি সাধারণভাবে না দেখে যেতে পারেন, যেমন ফাংশনের অর্গুমেন্ট টাইপ ভুল হওয়া, বা অপরিচিত ভেরিয়েবল ব্যবহার করা।

### 5. **Strict Mode চালু করা:**

**Strict Mode** চালু করতে দুটি উপায় আছে:

- **CLI কমান্ড ব্যবহার করে:** আপনি `--strict` ফ্ল্যাগ ব্যবহার করে TypeScript কম্পাইলারকে কঠোরভাবে টাইপ চেক করতে বলতে পারেন। যেমন:

  ```bash
  tsc --strict hello.ts
  ```

- **tsconfig.json ফাইলে `"strict": true` সেট করা:** আপনার `tsconfig.json` ফাইলে `"strict": true` লিখে Strict Mode চালু করতে পারেন। এটি কোডে সমস্ত Strict টাইপ চেকিং ফিচার চালু করবে। যেমন:

  ```json
  {
    "compilerOptions": {
      "strict": true
    }
  }
  ```

### 6. **Strictness Flags:**

TypeScript এ **strictness flags** অনেকগুলো রয়েছে, যেগুলি আপনি প্রয়োজনে চালু বা বন্ধ করতে পারেন। **Strict Mode** চালু করার পর, এই সব flag এর মাধ্যমে আপনি আলাদা আলাদা ভাবে টাইপ চেকিং কাস্টমাইজ করতে পারবেন।

#### দুটি গুরুত্বপূর্ণ strictness flag:

1. **noImplicitAny**:
   - যখন TypeScript কোনো ভেরিয়েবলের টাইপ বুঝতে পারে না এবং আপনি টাইপ উল্লেখ না করলে, তখন TypeScript সেই ভেরিয়েবলটির টাইপ **`any`** হিসেবে ধরে নেয়।
   - **noImplicitAny** চালু থাকলে, TypeScript আপনাকে এরকম **`any`** টাইপ ব্যবহারের জন্য ত্রুটি দেখাবে।
   - উদাহরণ:

     ```typescript
     let message;
     message = "Hello"; // noImplicitAny চালু থাকলে এর জন্য ত্রুটি দেখাবে।
     ```

2. **strictNullChecks**:
   - TypeScript এ ডিফল্টভাবে, **null** এবং **undefined** এর জন্য কোনো কঠোর চেকিং হয় না। 
   - **strictNullChecks** চালু থাকলে TypeScript আপনাকে `null` বা `undefined` এর ব্যবহার সম্পর্কে সতর্ক করবে। এর মানে হল যে আপনি একটি ভেরিয়েবলে **null** বা **undefined** অনুমোদন করলে, TypeScript তা চেক করবে এবং ত্রুটি দেখাবে যদি আপনি একে ভুলভাবে ব্যবহার করেন।
   - উদাহরণ:

     ```typescript
     let person: string | null;
     person = null; // strictNullChecks চালু থাকলে এটি ত্রুটি হতে পারে
     ```

### 7. **Strict Mode ব্যবহার করা উচিত কিনা?**

যদি আপনি নতুন কোডবেস তৈরি করছেন, তবে **Strict Mode** চালু রাখা উচিত। এর মাধ্যমে TypeScript আপনাকে কোডের আরো ভুল ধরতে সাহায্য করবে এবং আপনার কোডের গুণমান বাড়াবে।

অতএব, যদিও **Strict Mode** কিছু অতিরিক্ত কাজ করতে হতে পারে, এটি কোডে ভুল এবং ত্রুটি কমাতে এবং ভবিষ্যতের বাগ প্রতিরোধে সহায়ক।


- **Strict Mode** TypeScript এর শক্তিশালী একটি ফিচার যা আপনার কোডকে আরও বেশি সঠিক এবং নির্ভরযোগ্য করে তোলে।
- আপনি **`noImplicitAny`** এবং **`strictNullChecks`** ফ্ল্যাগ ব্যবহার করে আপনার কোডের টাইপ চেকিং আরো কঠোর করতে পারেন।
- সাধারণভাবে, **Strict Mode** আপনার কোডের গুণমান বাড়ায় এবং ভবিষ্যতে সৃষ্ট ত্রুটি এবং বাগ কমায়, তাই নতুন প্রজেক্টে এটি চালু রাখা উচিত।



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 **strictNullChecks**

### 1. **strictNullChecks এর কাজ:**

যখন আপনি TypeScript-এ `strictNullChecks` চালু করেন, তখন **null** এবং **undefined** এর জন্য কঠোর চেকিং করা হয়। এর মানে হল যে TypeScript এ **null** বা **undefined** একটি ভেরিয়েবলের বৈধ মান নয়, যদি না আপনি সেই ভেরিয়েবলের টাইপের মধ্যে **null** বা **undefined** উল্লেখ করেন।

উদাহরণস্বরূপ, যদি আপনি একটি ভেরিয়েবলকে `string` টাইপ হিসেবে ডিফাইন করেন, তবে সেটি কখনও **null** বা **undefined** হতে পারবে না, যদি না আপনি সেটি `string | null` বা `string | undefined` টাইপ হিসেবে উল্লেখ করেন।

### 2. **StrictNullChecks চালু থাকলে কী হয়?**

যখন `strictNullChecks` চালু থাকে, TypeScript আপনাকে এমন ভেরিয়েবল ব্যবহার করতে বাধা দেয় যা **null** বা **undefined** হতে পারে, যদি আপনি সেগুলো টাইপে উল্লেখ না করেন। এভাবে, আপনি যদি `null` বা `undefined` কিছু ভেরিয়েবল পাস করেন, তবে TypeScript তা ভুল হিসেবে চিহ্নিত করবে এবং ত্রুটি দেখাবে।

### 3. **আপনার কোডের ব্যাখ্যা:**

```typescript
let person: string | null;
person = null; // strictNullChecks চালু থাকলে এটি ত্রুটি হতে পারে
```

এখানে, আপনি `person` নামক একটি ভেরিয়েবল ডিফাইন করেছেন যার টাইপ হল `string | null` (অর্থাৎ, এটি একটি স্ট্রিং বা **null** হতে পারে)। `strictNullChecks` চালু থাকলে **null** এবং **undefined**-এর জন্য অতিরিক্ত নিরাপত্তা চেক থাকে। সেক্ষেত্রে, যদি আপনি `null` মানটি ভেরিয়েবলে অ্যাসাইন করেন, TypeScript হয়তো ত্রুটি দেখাবে কারণ এটি মনে করতে পারে যে আপনি **null** ভুলভাবে পাস করেছেন, যদিও আপনি এখানে `string | null` টাইপ দিয়েছেন।

তবে, `strictNullChecks` চালু না থাকলে, আপনি সহজেই **null** বা **undefined** মান অ্যাসাইন করতে পারবেন যেহেতু TypeScript সেগুলোকে যথাযথভাবে অনুমোদন করবে।

### 4. **StrictNullChecks চালু করা:**

আপনি যদি `strictNullChecks` চালু করতে চান, তাহলে আপনাকে আপনার **tsconfig.json** ফাইলে এটি সেট করতে হবে।

```json
{
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

এতে **strictNullChecks** এর অধীনে TypeScript আপনাকে **null** এবং **undefined** ব্যবহারের ক্ষেত্রে কঠোরভাবে সতর্ক করবে।

### 5. **কীভাবে সমস্যা সমাধান করবেন?**

যদি আপনি চান যে আপনার কোডে **null** বা **undefined** বৈধভাবে পাস হতে পারে, তবে আপনাকে আপনার ভেরিয়েবলের টাইপ স্পেসিফিক করতে হবে যেমন:

```typescript
let person: string | null = null;
```

এখানে, TypeScript জানে যে `person` ভেরিয়েবলটি **null** বা **string** হতে পারে, তাই এটি ত্রুটি দেখাবে না। 

এটা মনে রাখতে হবে যে, **strictNullChecks** চালু থাকলে TypeScript আপনার কোডে `null` বা `undefined` ব্যবহারের ক্ষেত্রে আরও সঠিক এবং নিরাপদ চেকিং করবে, যাতে আপনার কোডের ভুল কমে যায় এবং ভবিষ্যতে কোনো সমস্যা না হয়। 



- **strictNullChecks** চালু থাকলে, TypeScript আপনাকে **null** এবং **undefined** এর জন্য কঠোরভাবে চেক করবে এবং ভুল সনাক্ত করবে।
- আপনি যদি **null** বা **undefined** অনুমোদিত করতে চান, তাহলে টাইপের মধ্যে `| null` বা `| undefined` নির্দিষ্ট করতে হবে।
- `strictNullChecks` আপনার কোডের নিরাপত্তা এবং নির্ভরযোগ্যতা বাড়ায়।


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**`noImplicitAny`** TypeScript-এর একটি গুরুত্বপূর্ণ সেটিং যা আপনার কোডে **implicit any** টাইপ ব্যবহারের ওপর কড়াকড়ি আরোপ করে। এটি আপনার কোডে `any` টাইপ ব্যবহার থেকে বিরত রাখে এবং আপনার কোডে টাইপের আরও সঠিক এবং শক্তিশালী প্রয়োগ নিশ্চিত করে।

### 1. **Implicit `any` কী?**

TypeScript সাধারণত একটি ভেরিয়েবলের টাইপ বুঝে নিতে পারে। এটি যখন কোনো ভেরিয়েবলের জন্য টাইপ নির্ধারণ করতে পারে না, তখন TypeScript সেই ভেরিয়েবলের জন্য `any` টাইপ দেয়। `any` টাইপ TypeScript-এ সবচেয়ে লিনিয়েন্ট (কম কঠোর) টাইপ এবং এটি JavaScript-এর মতো আচরণ করে, কারণ এতে কোনো টাইপ চেকিং করা হয় না।

এটি অনেক ক্ষেত্রেই সমস্যা তৈরি করতে পারে, কারণ আপনি যখন `any` ব্যবহার করেন, তখন TypeScript আপনার কোডে কোনো টাইপ-সংশ্লিষ্ট ত্রুটি চেক করবে না। ফলে, এর মাধ্যমে টাইপ সেফটি হারিয়ে যেতে পারে এবং TypeScript-এর পুরো সুবিধাই নষ্ট হয়ে যায়।

### 2. **`noImplicitAny` এর ভূমিকা:**

`noImplicitAny` চালু থাকলে, TypeScript স্বয়ংক্রিয়ভাবে `any` টাইপ প্রাপ্ত কোনো ভেরিয়েবল বা ফাংশনে টাইপ এ্যাসাইন না করা থাকলে ত্রুটি দেখাবে।

যেমন:
```typescript
function greet(person) {
  console.log(`Hello ${person}`);
}
greet("John");
```

এখানে `person` এর টাইপ TypeScript সঠিকভাবে অনুমান করতে পারবে না, এবং এটি `any` টাইপ অ্যাসাইন করবে। তবে, যদি আপনি `noImplicitAny` চালু রাখেন, TypeScript এরকম কোডে ত্রুটি দেখাবে।

### 3. **`noImplicitAny` চালু করলে কী হয়?**

যখন আপনি **`noImplicitAny`** চালু করবেন, TypeScript তখন এমন কোনো ভেরিয়েবল বা প্যারামিটারকে অনুমোদন করবে না যার টাইপ নেই এবং যেটি `any` টাইপ হিসেবে বিবেচিত হতে পারে। এর ফলে, TypeScript আপনার কোডের মধ্যে `any` টাইপ প্রাপ্ত ভেরিয়েবল বা প্যারামিটারগুলোর জন্য একটি ত্রুটি দেখাবে।

এটি আপনাকে টাইপ স্পেসিফিকেশন যোগ করার জন্য উৎসাহিত করবে এবং আপনার কোডে টাইপ সেফটি নিশ্চিত করবে।

### 4. **কীভাবে `noImplicitAny` চালু করবেন?**

আপনি `tsconfig.json` ফাইলে `noImplicitAny` অপশনটি চালু করতে পারেন। এটি করলে TypeScript আপনার কোডে `any` টাইপ প্রয়োগ করতে পারবে না এবং আপনি এ বিষয়ে সতর্ক হবেন।

```json
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```

এটি চালু করার পর, যদি আপনি কোনো ভেরিয়েবল বা ফাংশনে টাইপ না দেন, তবে TypeScript সেগুলোতে ত্রুটি দেখাবে।

### 5. **উদাহরণ:**

#### ১. **`noImplicitAny` চালু না থাকলে:**

```typescript
function greet(person) {
  console.log(`Hello ${person}`);
}
greet("John");
```

এখানে `person` প্যারামিটারটি `any` টাইপে পরিণত হবে। TypeScript কোনো ত্রুটি দেখাবে না, কারণ `noImplicitAny` চালু হয়নি।

#### ২. **`noImplicitAny` চালু হলে:**

```typescript
function greet(person) {
  console.log(`Hello ${person}`);
}
greet("John");
```

এখন `noImplicitAny` চালু থাকলে TypeScript ত্রুটি দেখাবে:

```
Parameter 'person' implicitly has an 'any' type.
```

এটি মানে, আপনি `person` প্যারামিটারের জন্য টাইপ নির্দিষ্ট করেননি, তাই TypeScript ত্রুটি দেখাচ্ছে। এই সমস্যা সমাধান করতে আপনাকে টাইপ স্পেসিফাই করতে হবে:

```typescript
function greet(person: string) {
  console.log(`Hello ${person}`);
}
greet("John");
```

এখন, কোডটি কোনো ত্রুটি ছাড়াই চলবে।

### 6. **`noImplicitAny` চালু করার সুবিধা:**

- **টাইপ নিরাপত্তা:** আপনার কোডে ভুল টাইপ ব্যবহারের সুযোগ কমে যায়।
- **ভুল ধারণা প্রতিরোধ:** TypeScript আপনাকে ভুল টাইপ ব্যবহারের জন্য সতর্ক করবে, যেমন `any` টাইপ ব্যবহারের জন্য।
- **সহজ ডিবাগিং:** টাইপ সঠিকভাবে নির্দিষ্ট করলে, ত্রুটি চিহ্নিত করা সহজ হয় এবং কোডের মান উন্নত হয়।

### 7. **নির্দেশনা:**

- **`noImplicitAny`** চালু রাখলে কোডের প্রতি আপনাকে আরও সতর্ক থাকতে হবে এবং টাইপ নির্দিষ্ট করতে হবে।
- এটি বড় প্রজেক্টে টাইপ নিরাপত্তা নিশ্চিত করতে এবং ভুল কমাতে সাহায্য করে।
- **`any`** যদি প্রয়োজনীয় না হয়, তবে যতটা সম্ভব তাকে এড়ানো উচিত।



`noImplicitAny` TypeScript-এর একটি শক্তিশালী বৈশিষ্ট্য, যা আপনার কোডের টাইপ নিরাপত্তা নিশ্চিত করে। এটি আপনাকে ভুল টাইপ ব্যবহারের বিরুদ্ধে সুরক্ষা প্রদান করে এবং টাইপ সঠিকভাবে নির্দিষ্ট করার জন্য উৎসাহিত করে। এর মাধ্যমে আপনি আরও স্থিতিশীল, ত্রুটিমুক্ত কোড লিখতে পারবেন।



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**AGAIN EXPLAIN  strictNullChecks** 
**`strictNullChecks`** TypeScript-এ একটি গুরুত্বপূর্ণ বৈশিষ্ট্য যা **null** এবং **undefined** ভ্যালুর ব্যবহারকে আরও স্পষ্ট এবং নিরাপদ করে তোলে। এটি কোডের মধ্যে **null** এবং **undefined** ব্যবহারে সতর্কতা এবং সঠিক চেকিং নিশ্চিত করতে সাহায্য করে। এই বৈশিষ্ট্যটি চালু রাখলে, TypeScript আপনার কোডে `null` এবং `undefined` এর ভুল ব্যবহারের জন্য আপনাকে সতর্ক করবে, যা অনেক বড় সমস্যা এবং বাগের কারণ হতে পারে।

### 1. **`strictNullChecks` কী?**
যখন `strictNullChecks` চালু থাকে, তখন **null** এবং **undefined** শুধুমাত্র সেই ধরনের ভেরিয়েবল বা প্রপার্টি দিয়ে অ্যাসাইন করা যাবে যেগুলোর টাইপ স্পষ্টভাবে **null** অথবা **undefined** হতে পারে। এর মানে হল যে **null** বা **undefined** কোনো টাইপের অংশ হতে পারবে না, যদি না সেটা স্পষ্টভাবে নির্ধারণ করা হয়। এটি আপনাকে নিশ্চিত করে যে আপনার কোডে **null** বা **undefined** ভুলভাবে ব্যবহৃত হচ্ছে না এবং আপনি সেগুলোর যথাযথ হ্যান্ডলিং করতে ভুলবেন না।

### 2. **`strictNullChecks` চালু না থাকলে কী হয়?**
যখন `strictNullChecks` **চালু** থাকে না, তখন TypeScript **null** এবং **undefined** ভ্যালুগুলোকে প্রায় সব ধরনের ভেরিয়েবলের জন্য অনুমোদন দেয়। অর্থাৎ, আপনি যেকোনো টাইপের ভেরিয়েবলে **null** বা **undefined** অ্যাসাইন করতে পারেন এবং TypeScript কোনো ত্রুটি দেখাবে না। 

যেমন:
```typescript
let name: string;
name = null; // কোনো ত্রুটি হবে না
```

এতে কোন সমস্যা হবে না, কিন্তু বাস্তবে **null** বা **undefined** ভ্যালু ভুলভাবে ব্যবহৃত হতে পারে এবং এটি বাগ তৈরি করতে পারে।

### 3. **`strictNullChecks` চালু হলে কী হয়?**
যখন `strictNullChecks` চালু থাকে, তখন **null** এবং **undefined** এর ব্যবহারে টাইপ চেকিং আরও কড়া হয়। এর মানে হল যে, আপনি যদি **null** অথবা **undefined** টাইপের জন্য কোনো ভেরিয়েবল ডিক্লেয়ার না করেন, তবে TypeScript আপনাকে ত্রুটি দেখাবে।

যেমন:
```typescript
let name: string;
name = null; // এর জন্য TypeScript ত্রুটি দেখাবে: 'null' is not assignable to type 'string'
```

এখানে **null** কে **string** টাইপে অ্যাসাইন করতে দেয়া হয়নি কারণ **strictNullChecks** চালু। TypeScript এ এটি একটি ভুল হিসেবে ধরা হয় এবং আপনাকে স্পষ্টভাবে **null** টাইপের জন্য ভেরিয়েবল ডিফাইন করতে হবে।

### 4. **কিভাবে `strictNullChecks` চালু করবেন?**

আপনি **`strictNullChecks`** চালু করতে পারেন `tsconfig.json` ফাইলে। এই ফাইলটি TypeScript কনফিগারেশনের জন্য ব্যবহৃত হয়।

**`tsconfig.json`** ফাইলে এটি যুক্ত করুন:

```json
{
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

এটি চালু করার পর, TypeScript কোডে **null** এবং **undefined** সঠিকভাবে পরিচালিত হবে।

### 5. **`strictNullChecks` এর উদাহরণ:**

#### ১. **`strictNullChecks` চালু না থাকলে:**

```typescript
let name: string;
name = null; // কোনো সমস্যা হবে না
```

এখানে `name` ভেরিয়েবলটি **string** টাইপের হলেও, আপনি এটিতে **null** অ্যাসাইন করতে পারছেন, এবং TypeScript কোনো ত্রুটি দেখাবে না।

#### ২. **`strictNullChecks` চালু হলে:**

```typescript
let name: string;
name = null; // ত্রুটি হবে: 'null' is not assignable to type 'string'
```

এখানে, `name` ভেরিয়েবলটি **string** টাইপের হওয়ায়, আপনি এটিতে **null** অ্যাসাইন করতে পারবেন না। TypeScript আপনাকে ত্রুটি দেখাবে এবং আপনি এই সমস্যাটি ঠিক করতে পারবেন।

### 6. **কেন `strictNullChecks` চালু করা উচিত?**

**`strictNullChecks`** চালু করার অনেক সুবিধা রয়েছে:

- **বাগ কমাতে সাহায্য করে:** `null` এবং `undefined` টাইপের ভুল ব্যবহারের কারণে যেসব বাগ তৈরি হয়, সেগুলি আপনি সহজে ধরতে পারবেন।
- **কোডের নিরাপত্তা বৃদ্ধি করে:** এই সেটিং চালু রাখলে, আপনি নিশ্চিত হতে পারবেন যে আপনার কোডে **null** বা **undefined** ভুলভাবে ব্যবহৃত হচ্ছে না, ফলে আপনার অ্যাপ্লিকেশন আরো সুরক্ষিত হবে।
- **সহজ ডিবাগিং:** যখন কোনো ভেরিয়েবল সঠিক টাইপ গ্রহণ না করে, TypeScript দ্রুত আপনাকে সমস্যাটি চিহ্নিত করতে সাহায্য করবে।

### 7. **`strictNullChecks` এর সাথে কিছু চ্যালেঞ্জ:**

- **কোডের কিছু জায়গায় কাজ করা কঠিন হতে পারে:** যদি আপনি পূর্বে JavaScript কোড ব্যবহার করে থাকেন এবং সেখানে `null` বা `undefined` ব্যবহৃত হয়, তবে আপনার কিছু কোড সংশোধন করতে হতে পারে।
- **টাইপ স্পেসিফিকেশন স্পষ্টভাবে দেওয়া প্রয়োজন:** আপনাকে যখন ভেরিয়েবল বা প্যারামিটার ডিফাইন করবেন, তখন সেগুলোর টাইপ নির্দিষ্ট করতে হবে, এবং **null** বা **undefined** এর ব্যবহারের সময় সতর্ক থাকতে হবে।


`strictNullChecks` TypeScript-এ একটি অত্যন্ত গুরুত্বপূর্ণ বৈশিষ্ট্য। এটি আপনাকে **null** এবং **undefined** এর ব্যবহারের ক্ষেত্রে সতর্ক থাকতে সাহায্য করে এবং আপনার কোডে বাগ কমানোর সুযোগ তৈরি করে। বড় এবং দীর্ঘস্থায়ী প্রজেক্টে এর সুবিধা অনেক বেশি, কারণ এটি কোডে সঠিক টাইপ সেফটি নিশ্চিত করে এবং ভবিষ্যতে ভুল বা বাগ কমাতে সাহায্য করে।

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

